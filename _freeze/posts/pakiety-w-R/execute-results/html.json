{
  "hash": "800369ea533888172ce0ecae3cb068e3",
  "result": {
    "markdown": "---\ntitle: \"Tworzenie pakietów w R\"\ndescription: \"Po co pisać własne pakiety w R? Widzę dwa powody. Po pierwsze możemy mieć pewną kolekcję funkcji, których często używamy w różnych analizach. Możemy je w pewnym momencie chcieć zebrać w jedno miejsce. Po drugie możemy chcieć się podzielić naszymi funkcjami z innymi, czy to z zespołem, czy ze światem. W obu przypadkach pakiet jest lepszą, bardziej uporządkowaną i łatwiejszą w używaniu opcją niż pliki ze skryptami.\"\nimage: ./headers/pakiety-w-R.webp\ntwitter-card:\n    image: \"/headers/pakiety-w-R.jpeg\"\ndate: \"2023-05-26\"\ncategories:\n    - R\n---\n\n\n\n\nPakiety to nic innego jak zbiory funkcji. Od zwykłych plików .R z funkcjami różnią się tym, że mają określoną strukturę, dzięki której można je potem zainstalować i szybko zacząć wykorzystywać. Pewnie pierwszym skojarzeniem z pisaniem pakietów jest udostępnianie ich całej społeczności przez CRAN. Owszem, można to zrobić, ale można mieć też prywatne pakiety trzymane na GitHubie. Wtedy taki pakiet może być chałupniczy, niepełny, nieelegancki, ale i tak jest lepszą drogą, niż luźne pliki z definicjami funkcji. Dzięki temu nie musimy od razu wszystkiego zrobić na tip-top, żeby każdy na świecie wygodnie korzystał z naszych trzech funkcji. Naszym celem jest w końcu **oszczędzenie sobie pracy, nie dołożenie**.\n\n# Przygotowanie\n\nDo tworzenia pakietów wykorzystujemy inne pakiety. Najważniejszym z nich jest `devtools`, który ciągnie za sobą cały szereg innych pakietów typu `roxygen2`, `usethis` czy `testthat`. Możesz nawet mieć już zainstalowane `devtools`, bo to w jego skład wchodzi funkcja `install_github()`, dzięki której instalujemy pakiety z GitHuba[^1]. Jeśli nie masz jeszcze zainstalowanego pakietu `devtools`, zainstaluj go teraz.\n\n[^1]: Funkcje `install_*()` zapewnia też mniejszy pakiet `remotes`, który jest praktycznie wycinkiem z `devtools`. Jeśli mamy `devtools`, nie potrzebujemy `remotes`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"devtools\")\n```\n:::\n\n\nW tym tekście będę używał pełnych nazw funkcji, np. `usethis::use_readme_md()`. Jeśli jednak na początku pracy załadujesz `devtools`, nie musisz później podawać nazw pakietów.\n\nNajprostszym sposobem na utworzenie zrębu pakietu R jest wykorzystanie menu do tworzenia projektów w RStudio. Podczas tworzenia projektu możemy wybrać jego typ i nas interesuje *R package*. W wygodnym kreatorze wpisujemy nazwę pakietu. Warto też zaznaczyć, że chcemy mieć do tego repozytorium Git. Jeśli zabieramy się za tworzenie pakietu, powinniśmy umieć choć w podstawowym stopniu korzystać z Gita. Jeśli nie znasz Gita, zachęcam do przeczytania [tego posta](./posts/git.qmd).\n\n![](ilustracje/pakiety-w-R/RStudio-wizard.png)\n\n# Struktura pakietu {#sec-structure}\n\nStworzony przez nas szkielet pakietu już ma określoną strukturę. W wybranym wcześniej folderze znajdziemy serię szczególnych plików i folderów, która potem będzie się rozrastać. Obecnie są to:\n\n-   `.gitignore` -- plik repozytorium mówiący, co Git ma ignorować (więcej o tym w [tekście o Git](./posts/git.qmd)).\n\n-   `.Rbuildignore` -- plik, w którym podajemy niestandardowe pliki, które z jakiegoś powodu znajdują się w folderze z naszym pakietem; jest to ważne, bo R-CMD-check (o którym więcej w podrozdziale [-@sec-r-cmd-check]) będzie na nas krzyczał, jeśli znajdzie niestandardowe pliki w nietypowych miejscach.\n\n-   `DESCRIPTION` -- metadane naszego pakietu, przede wszystkim nazwa, wersja, autorzy i pakiety, których nasz pakiet wymaga do działania.\n\n-   `man` -- folder z plikami .Rd z dokumentacją naszych funkcji; nie edytujemy ich ręcznie.\n\n-   `NAMESPACE` -- plik z przestrzenią nazw naszego pakietu; nie edytujemy go ręcznie.\n\n-   `R` -- folder, do którego wrzucamy pliki .R z naszymi funkcjami; najważniejsza część naszego pakietu.\n\nDo tego jeszcze znajdziemy tam plik z projektem RStudio. W miarę budowania naszego pakietu, nasz folder będzie się zaludniał nowymi plikami i podfolderami.\n\nJuż teraz warto jest uruchomić kilka komend z pakietu `usethis`, które ułatwią nam robotę w przyszłości. Są to funkcje, których zazwyczaj używamy tylko raz, one wykonują swoją robotę (coś tworzą, coś dopisują) i zapominamy o ich istnieniu, aż nie musimy stworzyć kolejnego pakietu.\n\nPo pierwsze musimy przygotować nasz pakiet do używania `roxygen2`, czyli specjalnego standardu generującego dokumentację naszych funkcji. Dzięki niemu nie musimy ręcznie babrać się z plikami .Rd. Zaczynamy więc od **usunięcia pliku `NAMESPACE`**, który wytworzyło RStudio. Dlaczego? Bo nasz plik `NAMESPACE` ma stworzyć `roxygen2`, a nie RStudio. Po usunięciu używamy komendy `roxygen2::roxygenise()`. Doda ona do pliku `DESCRIPTION` informację o używanej wersji `roxygen2` oraz stworzy nowy, piękny, prawie pusty plik `NAMESPACE`. Następnie używamy komendy `usethis::use_roxygen_md()`[^2]. Pozwoli ona używać nam wygodnej składni markdown w dokumentacji, np. \\*\\***bold**\\*\\* wygeneruje nam pogrubiony tekst. Więcej o podstawach markdown przeczytamy na przykład [tutaj](https://quarto.org/docs/authoring/markdown-basics.html).\n\n[^2]: Jeśli już wcześniej stworzyłeś(-aś) jakieś pliki z funkcjami i je udokumentowałeś(-aś), to użyj teraz `roxygen2md::roxygen2md()`, by przerobić je na nowy standard. Jeśli tworzysz pakiet w kolejności, w jakiej omawiam to w tym wpisie, nie ma takiej potrzeby.\n\n# `DESCRIPTION`\n\nPlik `DESCRIPTION`, jak już wspomniałem, to opis naszego pakietu. Jeśli otworzymy go teraz, zobaczymy przygotowany wcześniej szkielet. Możemy w nim uzupełnić tytuł, wersję i opis pakietu. Jeśli opis zajmie więcej niż linijkę, kolejne linijki powinny zaczynać się wcięciem wielkości 4 spacji.\n\n## Autorzy\n\nJeśli chodzi o autorów pakietu, podajemy ich w dość specyficzny sposób. Najpierw jednak kasujemy całą linijkę `Maintainer`. To część starego standardu, dziś osobę odpowiedzialną za kod podajemy w polu autorów. Samych autorów podamy za pomocą funkcji `person()`. Pokażmy to sobie na przykładzie.\n\n\n::: {.cell filename='DESCRIPTION'}\n\n```{.r .cell-code}\nAuthors@R: person(\n      \"Jakub\", \"Jędrusiak\",\n      email = \"kuba23031999@gmail.com\",\n      role = c(\"aut\", \"cre\"),\n      comment = c(\n        ORCID = \"0000-0002-6481-8210\",\n        affiliation = \"University of Wrocław\"\n        )\n      )\n```\n:::\n\n\nPo pierwsze znacznik `Author` zmieniamy na `Authors@R` i to niezależnie od liczby autorów. Jeśli autor jest jeden, podajemy go za pomocą funkcji `person()`. Podstawowe informacje to imię w pierwszym argumencie[^3], nazwisko w drugim. Tych argumentów nie musimy nazywać. Dalej mamy inne informacje, które już nazwać warto. `email` jaki jest, każdy widzi. `role` to opis funkcji osoby w tworzeniu pakietu. Używamy tutaj kodów opisanych w dokumentacji funkcji `person()`. Kilka podstawowych kodów ról wymieniam w tabeli poniżej. Jak widać w przykładzie, każda osoba może mieć więcej niż jedną rolę. Kolejnym polem jest `comment`, który *zawsze* podajemy w postaci nazwanego wektora. Podstawowymi informacjami, które możemy tutaj umieścić, są numer ORCiD oraz afiliacja.\n\n[^3]: Jeśli chcemy podać dwa imiona, podajemy je jako wektor, np. `c(\"Paweł\", \"Przemysław\")`.\n\n| Kod     | Funkcja            | Opis                                                                                            |\n|------------|------------|------------------------------------------------|\n| `\"aut\"` | *Author*           | Pełny autor; wszystkie osoby, które pojawiają się w cytowaniu, powinny mieć przypisaną tę rolę. |\n| `\"cre\"` | *Creator*          | Osoba odpowiedzialna za dbanie o kod w pakiecie (*maintainer*).                                 |\n| `\"ctb\"` | *Contributor*      | Osoby, które wniosły jakiś istotny wkład w pakiet, ale za mały, by pojawiać się w cytowaniu.    |\n| `\"cph\"` | *Copyright holder* | Osoba lub instytucja posiadająca prawa autorskie do pakietu.                                    |\n\nJeśli autorów jest więcej niż jeden, podajemy ich w postaci wektora osób. Poniżej przykład.\n\n\n::: {.cell filename='DESCRIPTION'}\n\n```{.r .cell-code}\nAuthors@R: c(\n    person(\n      \"Boris\", \"Forthmann\",\n      email = \"boris.forthmann@uni-muenster.de\",\n      role = \"aut\",\n      comment = c(\n        ORCID = \"0000-0001-9755-7304\",\n        affiliation = \"University of Münster\"\n      )\n    ),\n    person(\n      \"Maciej\", \"Karwowski\",\n      email = \"maciej.karwowski@uwr.edu.pl\",\n      role = \"aut\",\n      comment = c(\n        ORCID = \"0000-0001-6974-1673\",\n        affiliation = \"University of Wrocław\"\n      )\n    ),\n    person(\n      c(\"Roger\", \"E.\"), \"Beaty\",\n      email = \"rebeaty@psu.edu\",\n      role = \"aut\",\n      comment = c(\n        ORCID = \"0000-0001-6114-5973\",\n        affiliation = \"Pennsylvania State University\"\n        )\n      ),\n    person(\n      \"Jakub\", \"Jędrusiak\",\n      email = \"kuba23031999@gmail.com\",\n      role = c(\"aut\", \"cre\"),\n      comment = c(\n        ORCID = \"0000-0002-6481-8210\",\n        affiliation = \"University of Wrocław\"\n        )\n      )\n    )\n```\n:::\n\n\n## `CITATION`\n\nJeśli chcemy, by nasz pakiet był cytowany w jakiś konkretny sposób, możemy wprost go wskazać w pliku `CITATION`. Wytwarzamy go już po uzupełnieniu koniecznych informacji w pliku `DESCRIPTION` za pomocą komendy `usethis::use_citation()`. Sam plik siedzi sobie w folderze `inst`. Umieszczamy w nim informacje o cytowaniu w formacie BibTeX (każdy generator potrafi taką wytworzyć), a jeśli chcemy, to także wersję tekstową. Decyduje to o sposobie, w jaki wyświetla się wynik funkcji `citation()`. Poniżej przykładowy plik `CITATION` i jego efekt.\n\n\n::: {.cell filename='CITATION'}\n\n```{.r .cell-code}\ncitHeader(\"To cite mtscr in publications use:\")\n\ncitEntry(\n  entry    = \"Manual\",\n  title    = \"Multidimensional Top Scoring for Creativity Research\",\n  author   = \"Boris Forthmann, Maciej Karwowski, Roger E. Beaty, Jakub Jędrusiak\",\n  year     = \"2023\",\n  url      = \"https://github.com/jakub-jedrusiak/mtscr\",\n  textVersion = paste(\n\"Forthmann, B., Karwowski, M., Beaty, R. E., Jędrusiak, J. (2023). Multidimensional Top Scoring for Creativity Research. Retrieved from: https://github.com/jakub-jedrusiak/mtscr\"\n  )\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncitation(\"mtscr\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTo cite mtscr in publications use:\n\n  Forthmann, B., Karwowski, M., Beaty, R. E., Jędrusiak, J. (2023).\n  Multidimensional Top Scoring for Creativity Research. Retrieved from:\n  https://github.com/jakub-jedrusiak/mtscr\n\nWpis BibTex dla użytkowników LaTeX to\n\n  @Manual{,\n    title = {Multidimensional Top Scoring for Creativity Research},\n    author = {Boris Forthmann and Maciej Karwowski and Roger E. Beaty and Jakub Jędrusiak},\n    year = {2023},\n    url = {https://github.com/jakub-jedrusiak/mtscr},\n  }\n```\n:::\n:::\n\n\n## Licencja\n\nSwój kod warto wprost licencjonować, ale licencji nie dodajemy do pakietu ręcznie. Używamy tutaj odpowiedniej funkcji z pakietu `usethis`, np. dla licencji MIT będzie to `usethis::use_mit_license()`, a dla GPL v.3 `usethis::use_gpl3_license()`. Pełną listę dostępnych licencji można znaleźć [tutaj](https://usethis.r-lib.org/reference/licenses.html). Jaką licencję wybrać? Najprościej mówiąc, MIT to *de facto* pójście we w pełni wolny kod. Taki kod może np. stać się częścią płatnego programu, ale nasze prawa autorskie w stosunku do niego ciągle obowiązują. GPL natomiast wymusza, by programy oparte na naszym kodzie też były licencjonowane pod GPL, czyli by zawsze były darmowe. Większość pakietów R (ok. 70%) korzysta z licencji GPL.\n\n## Zależności {#sec-dependencies}\n\nNajpewniej nie będziemy pisać całego naszego kodu w podstawowym R, a raczej będziemy wykorzystywać w nim inne pakiety. Żeby dodać jakiś pakiet jako zależność, używamy np. `usethis::use_package(\"rlang\", \"dplyr\")`. Nie należy nigdy podawać `tidyverse` jako zależności, a raczej konkretne pakiety typu `dplyr` czy `stringr`. Do tego możemy wymusić wykorzystanie konkretnej minimalnej wersji danego pakietu argumentem `min_version`, np. pisząc `usethis::use_package(\"dplyr\", min_version = \"1.1.0\")`.\n\nJeśli zerkniemy w plik `DESCRIPTION` po uruchomieniu takiej komendy, zobaczymy, że dodane pakiety znalazły się w sekcji `Imports`. Tak powinno być. Istnieją jednak inne możliwe sekcje. Jeśli dodajemy pakiet, który nie jest potrzebny do działania naszych funkcji, ale na przykład potrzebujemy go do uruchomienia przykładów (bo chociażby wykorzystujemy w nich dane `diamonds` z pakietu `ggplot2`, podczas gdy nie wykorzystujemy samego `ggplot2` w naszych funkcjach), dodajemy go w sekcji `Suggests`. Robimy to pisząc na przykład `usethis::use_package(\"ggplot2\", type = \"Suggests\")`.\n\nIstnieje seria zależności, które posiada większość pakietów i które można łatwo dodać poprzez specjalne funkcje z pakietu `usethis`. Wymieńmy sobie te najważniejsze:\n\n1.  `usethis::use_pipe()` -- dodaje obsługę potoków `%>%` z pakietu `magrittr`.\n\n2.  `usethis::use_tibble()` -- dodaje obsługę `tibble` jako formy, w której nasze funkcje zwracają dane.\n\n3.  `usethis::use_tidy_dependencies()` -- standardowe zależności typu `rlang`, `cli` czy `glue`. Według mnie powinno się uruchamiać zawsze.\n\n4.  `usethis::use_tidy_eval()` -- podstawowe pakiety do [Tidy Eval](./posts/metaprogramowanie.qmd). Według mnie powinno się uruchamiać zawsze.\n\n5.  `usethis::use_lifecycle()` -- dodaje zależność od pakietu `lifecycle`, dzięki któremu możemy oznaczyć nasze funkcje jako eksperymentalne albo wycofane. Więcej informacji [tutaj](https://lifecycle.r-lib.org/index.html).\n\nDodatkowo większość pakietów posiada wprost wskazaną zależność od samego R. Taka zależność musi pojawić się w sekcji `Depends` (zamiast standardowego `Imports`) i musi uwzględniać minimalną wersję co najmniej 3.5.0[^4]. W praktyce najlepiej jest podawać minimalną wersję 4.1.0, bo w tej wersji dodano natywny potok `|>`, a już w ogóle najlepiej nie cofać się przed 4.2.0, kiedy potoki wzbogacono o `_`, czyli informację, gdzie ma się znaleźć dany argument, jeśli nie na pierwszym miejscu (odpowiednik `.` w `magrittr`). Można to wykonać funkcją `usethis::use_package(\"R\", type = \"Depends\", min_version = \"4.2.0\")`. Zwrócę tutaj uwagę, że trzecia liczba w zależności od R **musi być zero**. Nie można podać na przykład zależności z minimalną wersją `4.2.2`.\n\n[^4]: Jest to wymagane, jeśli wykorzystujemy pliki z danymi. Technicznie można dać niższą wersję, ale nie polecam.\n\n# `README`\n\nKażde repozytorium powinno mieć plik README, czyli opis, który wyświetli się na stronie pakietu na GitHubie. Gdy tworzymy pakiet R, mamy dwie możliwości, jakiego rodzaju plik README wytworzymy.\n\n1.  `README.md` -- opcja klasyczna, wytwarza zwykły plik markdown.\n\n2.  `README.Rmd` -- opcja fajniejsza, wytwarza plik .Rmd, w którym możemy dorzucać przykładowy kod w R razem z jego efektami.\n\nPierwsza opcja wymaga użycia komendy `usethis::use_readme_md()`. Wytworzy ona zwykły plik .md, który możemy wypełnić korzystając z [instrukcji na GitHubie](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax). Jeśli chcemy zyskać dostęp do możliwości oferowanych przez RMarkdown, używamy `usethis::use_readme_rmd()`. Wytworzy to plik .Rmd, w którym możemy pokazać, na co stać nasz pakiet. Dokładny opis składni znajdziemy [tutaj](https://rmarkdown.rstudio.com/), zaś poniżej przykład.\n\n```` code-overflow-wrap\nThe main function is `mtscr_scores()` which can return a df with scores for each participant, each item or each participant-item combination. Scores come from two models – `all_max` and `all_top2`. A value for a participant is the maximum value predicted by the model for that participant.\n\n```{{r}}\nlibrary(\"mtscr\")\ndata(\"mtscr_creativity\", package = \"mtscr\")\n```\n````\n\n::: light-mode\n![Efekt działania kodu RMarkdown z ramki na GitHubie.](ilustracje/pakiety-w-R/Rmarkdown.png)\n:::\n\n::: dark-mode\n![Efekt działania kodu RMarkdown z ramki na GitHubie.](ilustracje/pakiety-w-R/Rmarkdown_dark.png)\n:::\n\nJeśli zdecydujemy się na tę opcję, zawsze edytujemy plik `README.Rmd`, a nie `README.md`. GitHub nie potrafi go jednak odczytać, dlatego przed wysłaniem naszych plików na serwer musimy przekonwertować plik `README.Rmd` do pliku `README.md`. Robimy to prostą komendą `devtools::build_readme()`. Komenda `usethis::use_readme_rmd()` dodatkowo dodaje specjalną przypominajkę, która nie pozwala nam zrobić commitu, jeśli zmienialiśmy plik `README.Rmd`, a go nie wyeksportowaliśmy.\n\nNa marginesie dodam, że RMarkdown jest powoli zastępowany przez bliźniaczy standard [Quarto](https://quarto.org/), ale w chwili, gdy to piszę, `usethis` [nie planuje go wdrażać](https://github.com/r-lib/usethis/issues/1671).\n\n## Odznaki\n\nBardzo często w repozytoriach znajdziemy odznaki. Są to elementy informacyjno-ozdobne, które mówią coś o naszym pakiecie, np. że przechodzi testy, że jest w CRAN albo ile razy w miesiącu ktoś go pobiera. Ciekawe odznaki obejmują:\n\n1.  Odznakę `R-CMD-check`, o której piszę w podrozdziale [-@sec-GitHubActions].\n\n2.  Odznakę `lifecycle`, którą możemy poinformować, że nasz pakiet jako całość jest eksperymentalny, stabilny lub wycofany. Możemy ją dodać wykorzystując komendę `usethis::use_lifecycle_badge(\"stable\")`. Argument wybieramy jaki chcemy, zgodnie z listą dostępną [tutaj](https://lifecycle.r-lib.org/articles/stages.html).\n\n3.  Odznakę CRAN, która informuje, jaka wersja naszego pakietu dostępna jest w CRAN. Jeśli pakiet nie jest dostępny, to odznaka też może o tym poinformować. Dodajemy ją komendą `usethis::use_cran_badge()`.\n\n::: light-mode\n![Kilka odznak w nagłówku pliku README na GitHubie.](ilustracje/pakiety-w-R/badges.png)\n:::\n\n::: dark-mode\n![Kilka odznak w nagłówku pliku README na GitHubie.](ilustracje/pakiety-w-R/badges_dark.png)\n:::\n\nOdznaki nie są obowiązkową częścią pakietu, ale piszę o nich, bo lubię takie ładne pierdółki. Inne przykłady odznak znajdziemy na [shields.io](https://shields.io/), albo wykorzystując pakiet [`badger`](https://github.com/GuangchuangYu/badger).\n\n# GitHub\n\nZazwyczaj swoje pakiety chcemy trzymać na GitHubie[^5], żeby łatwo je instalować. Żeby podłączyć nasze repozytorium do GitHuba, musimy użyć po kolei dwóch komend.\n\n[^5]: Jeśli nie wiesz, czym jest GitHub i po co go używać, przeczytaj [ten wpis](./posts/git.qmd).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_git()\nusethis::use_github(private = TRUE)\n```\n:::\n\n\nPierwsza dostosuje nasze repozytorium do ogólnych dobrych standardów. Druga podłączy nas do GitHuba, wytwarzając nowe repozytorium. Jeśli chcemy, by było prywatne, ustawiamy `private = TRUE`.\n\n## R-CMD-check na GitHubie {#sec-GitHubActions}\n\nKolejną polecaną przeze mnie czynnością, która (według mnie) powinna zostać wykonana w każdym repozytorium, jest uruchomienie tej komendy:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_github_action_check_standard()\n```\n:::\n\n\nDodaje ona kilka rzeczy. Po pierwsze sprawia ona, że po każdym naszym commicie GitHub wykonuje zestaw podstawowych testów zwanych R-CMD-check, o których więcej piszę w podrozdziale [@sec-r-cmd-check]. W drugiej kolejności dodaje ona odznakę R-CMD-check do naszego pliku `README`, żebyśmy mogli błyszczeć przechodzeniem testów.\n\n# Pliki z funkcjami\n\nPrzyszedł czas dodać jakieś rzeczywiste funkcje. Pisanie funkcji stanowiących część pakietu jest prawie identyczne jak pisanie zwyczajnych funkcji. Jak podam dalej, możemy chcieć postarać się bardziej i np. zabezpieczyć nasze funkcje przed błędami, ale znowu -- nie musimy. Podstawowe pułapki przy pisaniu własnych funkcji w ogóle (nie tylko w pakietach) obejmują użeranie się z Tidy Eval, o którym piszę [tutaj](./posts/metaprogramowanie.qmd).\n\nŻeby dodać jakieś funkcje do swojego pakietu, używamy funkcji `usethis::use_r()`[^6], gdzie jako argument podajemy nazwę pliku z funkcją. W większości przypadków będzie to nazwa samej funkcji, np. jeśli chcemy stworzyć funkcję do liczenia statystyk opisowych, moglibyśmy napisać `usethis::use_r(\"opisowe\")`. Możemy też zawrzeć kilka funkcji w jednym pliku, ale powinny być to bardzo blisko związane funkcje. Na tyle blisko związane, żeby mogły dzielić jedną stronę w dokumentacji. Przykładem takich funkcji może być na przykład rodzina `devtools::install_*()` albo `usethis::use_*_license()`. Wszystkie funkcje z tych zestawów są prawie identyczne, więc mogą być zgromadzone w jednym pliku.\n\n[^6]: Możesz też ręcznie wytworzyć odpowiedni plik .R w folderze `R`.\n\nNiezależnie jednak, czy robimy mały pakiecik do użytku własnego, czy może coś, co chcemy ostatecznie umieścić w CRAN, warto swoje funkcje udokumentować. Dokumentacja w R jest cudowna, łatwa w obsłudze i zawsze dostępna. Potraktuj swoją dokumentację jako ustrukturyzowane notatki, dzięki którym nie zapomnisz, na czym polegały Twoje funkcje i jak ich używać.\n\n## Specyficzne wymogi CRAN i R-CMD-check {#sec-cran-checks}\n\nZałóżmy, że napisaliśmy już własną funkcję, która liczy podstawowy zestaw statystyk opisowych i zwraca je w ulubionej przez nas formie. Wykorzystam tutaj funkcję z [tekstu o metaprogramowaniu](./posts/metaprogramowanie.qmd). Definicję zapisuję w pliku `opisowe.R`, jaki wytworzyłem w poprzednim akapicie w folderze `R`.\n\n\n::: {.cell filename='opisowe.R'}\n\n```{.r .cell-code}\nopisowe <- function(df, group, ...) {\n  kolumny_do_policzenia <- enquos(...)\n\n  df %>%\n    group_by({{ group }}) %>%\n    summarise(\n      across(\n        c(!!!kolumny_do_policzenia),\n        .fns = list(\n          N = \\(x) sum(!is.na(x)),\n          M = \\(x) mean(x, na.rm = TRUE),\n          SD = \\(x) sd(x, na.rm = TRUE),\n          A = agricolae::skewness,\n          K = agricolae::kurtosis,\n          `NA` = \\(x) sum(is.na(x))\n        )\n      )\n    )\n}\n```\n:::\n\n\nPonieważ jest to pakiet, musimy trochę przepisać naszą funkcję, jeśli nie chcemy, żeby R-CMD-check później na nas krzyczał. Jeśli nas to nie obchodzi, możemy to pominąć, ale lepiej jest od razu nabierać dobrych nawyków. Takie dopasowywanie funkcji dotyczy zazwyczaj tylko kilku rzeczy, z których najważniejsza to globalne definicje obiektów. R musi wiedzieć dokładnie, czym są pokazywane mu obiekty, żeby się nie buntował, niezależnie od tego, czy tym obiektem jest funkcja, czy baza danych.\n\n1.  Funkcje powinny być zapisane w postaci pełnych nazw, czyli np. `dplyr::group_by()`. Pakiety, z których pochodzą te funkcje, powinny być dodane jako zależności (por. podrozdział [-@sec-dependencies]). Jeśli użyliśmy `usethis::use_tidy_eval()` (por. podrozdział [-@sec-dependencies]), to funkcje z pakietu `rlang` są ładowane z automatu i nie potrzebują pełnych nazw.\n\n2.  Jeśli w funkcjach typu `mutate()` wykorzystujemy nazwy kolumn bez cudzysłowu, np. `mutate(iris, millimeters = Sepal.Length * 10)`, R-CMD-check będzie krzyczał, że `Sepal.Length` nie ma globalnej definicji. W takim wypadku używamy wyrażenia `.data` z `rlang` i piszemy `dplyr::mutate(iris, millimeters = .data$Sepal.Length * 10)`.\n\n3.  Jeśli w funkcjach wybierających kolumny (przede wszystkim `select()`) piszemy nazwy kolumn, to podajemy je w cudzysłowie. Powód jest taki, jak wyżej, brak globalnej definicji, ale `.data` nie nadaje się do `tidyselect`. Dla przykładu zamiast `select(iris, Sepal.Width, Sepal.Length)` powinniśmy napisać `dplyr::select(iris, \"Sepal.Width\", \"Sepal.Length\")`.\n\n4.  Na ogół lepiej używać natywnego potoku `|>` niż `%>%`. Jeśli chcemy używać potoku z `magrittr` używamy wcześniej `usethis::use_pipe()`. Natywny potok oszczędza nam dodatkowej zależności.\n\nPoprawiona funkcja mogłaby więc wyglądać tak:\n\n\n::: {.cell filename='opisowe.R'}\n\n```{.r .cell-code}\nopisowe <- function(df, group, ...) {\n  kolumny_do_policzenia <- enquos(...)\n\n  df |>\n    dplyr::group_by({{ group }}) |>\n    dplyr::summarise(\n      dplyr::across(\n        c(!!!kolumny_do_policzenia),\n        .fns = list(\n          N = \\(x) sum(!is.na(x)),\n          M = \\(x) mean(x, na.rm = TRUE),\n          SD = \\(x) stats::sd(x, na.rm = TRUE),\n          A = agricolae::skewness,\n          K = agricolae::kurtosis,\n          `NA` = \\(x) sum(is.na(x))\n        )\n      )\n    )\n}\n```\n:::\n\n\n## Dokumentowanie z `roxygen2`\n\nGdy mamy już naszą funkcję napisaną, przyszedł czas ją udokumentować. Niezależnie, czy robimy mały pakiecik do użytku własnego, czy może coś, co chcemy ostatecznie umieścić w CRAN, warto tego nie zaniedbywać. Dokumentacja w R jest cudowna, łatwa w obsłudze i zawsze dostępna. Potraktuj swoją dokumentację jako ustrukturyzowane notatki, dzięki którym nie zapomnisz, na czym polegały Twoje funkcje i jak ich używać. Tworzymy ją za pomocą specjalnego szkieletu obsługiwanego przez pakiet `roxygen2`. Możemy albo napisać taki szkielet od podstaw, albo wejść kursorem tesktowym do naszej funkcji i w RStudio z menu Code wybrać Insert Roxygen Skeleton (skrót klawiaturowy Ctrl+Alt+Shift+R). Taki szkielet szkieletu uzupełniamy ręcznie. Pokażmy to sobie na przykładzie.\n\n\n::: {.cell filename='opisowe.R'}\n\n```{.r .cell-code}\n#' Statystyki opisowe\n#'\n#' Funkcja licząca podstawowe statystyki opisowe: liczność, średnią, SD,\n#' skośność, kurtozę i liczbę braków danych.\n#'\n#' @param df ramka danych z kolumnami do policzenia.\n#' @param group kolumna do grupowania.\n#' @param ... nazwy kolumn, dla których mają być policzone statystyki.\n#'\n#' @return ramka danych z kolumnami `N`, `M`, `SD`, `A`, `K` i `NA`. Oryginalne nazwy\n#'     kolumn w formie przedrostka.\n#' @export\n#'\n#' @examples\n#' opisowe(iris, Species, Sepal.Width, Sepal.Length)\n```\n:::\n\n\nPierwszym, co zwraca uwagę, jest fakt, że napisałem to po polsku. Owszem, można, ale jeśli chcemy udostępniać nasz kod na zewnątrz, lepiej dokumentować pakiet po angielsku.\n\nTen podstawowy opis funkcji zawiera kilka rzeczy:\n\n1.  Na samej górze znajduje się tytuł funkcji, który lapidarnie ale konkretnie opisuje jej przeznaczenie.\n\n2.  Dalej opis działania funkcji. Również powinien być krótki i konkretny. Jeśli potrzebujemy więcej niż jednego akapitu, musimy jawnie napisać `@description`. W innym wypadku wystarczy zejść linijkę poniżej tytułu, tak jak pokazałem w przykładzie.\n\n3.  Następnie mamy trzy tagi `@param`, z których każdy opisuje kolejny argument, jaki funkcja przyjmuje. Warto tutaj opisać postać, w jakiej argument musi zostać podany, np. *logical* albo *dataframe*.\n\n4.  Tag `@return` opisuje, co funkcja zwraca. W tym wypadku jest to opis stworzonej ramki danych ze statystykami opisowymi.\n\n5.  Tag `@export` nie zawiera żadnych informacji. Umieszcza się go w tych funkcjach, do których użytkownik powinien mieć dostęp.\n\n6.  Na samym końcu mamy `@examples`, czyli przykłady użycia funkcji. Przykłady są obowiązkowe i obowiązkowo muszą zadziałać. Jeśli jakiś przykład specjalnie zwraca błąd (możemy w końcu chcieć pokazać, jak naszej funkcji *nie* używać), należy go umieścić w klamrze `\\dontrun{}`, np. `\\dontrun{opisowe(iris)}`.\n\nDo wymienionych wyżej podstawowych tagów możemy dodać także m.in. sekcje `@details` czy `@seealso`. Poniżej przykład strony w dokumentacji generowanej przez podstawowe tagi.\n\n::: light-mode\n![Dokumentacja funkcji `opisowe()`.](ilustracje/pakiety-w-R/dokumentacja.png)\n:::\n\n::: dark-mode\n![Dokumentacja funkcji `opisowe()`.](ilustracje/pakiety-w-R/dokumentacja_dark.png)\n:::\n\nŻeby przerobić szkielety `roxygen2` na rzeczywiste pliki dokumentacji (czyli pliki .Rd w folderze .man), należy uruchomić komendę `devtools::document()`. Tutaj zaczynają się ujawniać komendy, których warto używać często, a już zwłaszcza przed wysłaniem aktualizacji na GitHuba. Zbieram je wszystkie na końcu, w podsumowaniu.\n\nW przykładzie widać teź, że mogę używać w swoich szkieletach formatowania markdown. Jest to jednak możliwe tylko, jeśli wcześniej użyłem `usethis::use_roxygen_md()`, o czym pisałem w podrozdziale [-@sec-structure].\n\n## Dokumentacja całego pakietu\n\nMożemy dodać ogólną stronę w dokumentacji dotyczącą naszego pakietu jako całości. Wykonuje się to w specjalnym pliku .R, który można dodać funkcją `usethis::use_package_doc()`. Jeśli jednak użyłeś(-aś) wcześniej funkcji `usethis::use_tidy_dependencies()`, to wymusiła ona na Tobie wytworzenie takiego pliku. Niezależnie od wybranej drogi, po uruchomieniu jednej z tych komend znajdziesz w folderze `R` plik o nazwie typu typu `packagename-package.R`, gdzie możesz napisać dokumentację pakietu standardowo, jak w każdym innym pliku .R.\n\n# Załączanie danych {#sec-datafiles}\n\nCzasami chcemy załączyć do naszego pakietu dane. Mogą być one wartością samą w sobie (jak np. w pakiecie `datasets`), mogą służyć do ilustracji działania reszty naszego pakietu. Niezależnie od celu, pliki z danymi trzeba załączać w odpowiedni sposób, a także je dokumentować.\n\n## Surowe dane w `data-raw`\n\nNa początku potrzebujemy surowego pliku z danymi, np. w formacie .csv. Wrzucamy go do folderu `data-raw`, który tworzymy w głównym folderze naszego pakietu. Następnie tworzymy skrypt czyszczący. Najłatwiej wytworzyć go funkcją `usethis::use_data_raw()`, która za pierwszy argument przyjmuje nazwę, którą chcemy naszej bazie danych nadać. Mogłoby to być coś w stylu `usethis::use_data_raw(\"iris\")`. Spowoduje to wytworzenie w folderze `data-raw` skryptu `iris.R`, który w tym momencie powinien nam się otworzyć w RStudio. Zawiera on tylko komentarz i jedną komendę `usethis::use_data()`. Powyżej tej komendy piszemy skrypt, który ładuje i czyści nasze surowe dane do takiej formy, którą chcemy załączyć w pakiecie. Gotowe dane zapisujemy do zmiennej o wybranej wcześniej nazwie. I to wystarczy. Podczas instalacji naszego pakietu zostaną załadowane też dane. Dostęp do nich możemy uzyskać za pomocą komendy, która w pełnej wersji ma postać `data(\"diamonds\", package = \"ggplot2\")`. Poniżej przykład gotowego skryptu ładującego.\n\n\n::: {.cell filename='mtscr_creativity.R'}\n\n```{.r .cell-code}\nmtscr_creativity <- readr::read_csv(\"data-raw/study2.csv\") |>\n  dplyr::select(-response_nofill, -item_nofill) |>\n  dplyr::filter(\n    item %in% c(\n      \"belt\", \"brick\", \"broom\",\n      \"bucket\", \"candle\", \"clock\",\n      \"comb\", \"knife\", \"lamp\",\n      \"pencil\", \"pillow\",\n      \"purse\", \"sock\"\n    ),\n    any(is.na(SemDis_MEAN))\n  )\n\nusethis::use_data(mtscr_creativity, overwrite = TRUE)\n```\n:::\n\n\n## Dokumentacja plików z danymi\n\nJeśli załączamy w naszym pakiecie dane, to je również powinniśmy udokumentować. Tworzymy w tym celu specjalny plik `data.R` w folderze `R`, w którym opisujemy wszystkie nasze pliki z danymi. Pod szkieletem `roxygen2` umieszczamy nazwę naszej bazy danych w cudzysłowie. Poniżej skrócony przykład.\n\n\n::: {.cell filename='data.R'}\n\n```{.r .cell-code}\n#' Creativity assessment through semantic distance dataset\n#'\n#' A dataset from Forthmann, Karwowski & Beaty ([2023](https://doi.org/10.1037/aca0000571)) paper.\n#' It contains a set of responses in Alternative Uses Task for different items with their\n#' semantic distance assessment.\n#'\n#' @return a [tibble][tibble::tibble-package]\n#' @format ## `mtscr_creativity`\n#' A `tibble` with 4585 rows and 3 columns:\n#' \\describe{\n#'   \\item{id}{patricipants' unique identification number}\n#'   \\item{response}{response in AUT}\n#'   \\item{item}{item for which alternative uses were searched for}\n#' }\n#'\n#' @source <https://osf.io/7rgsp/>\n\"mtscr_creativity\"\n```\n:::\n\n\nSpecyficzne tagi to `@format`, w którym opisujemy **każdą kolumnę** i `@source`, w którym podajemy źródło naszych danych. `\\describe{}` to sposób na dodanie do dokumentacji listy.\n\n# R-CMD-check {#sec-r-cmd-check}\n\nJeśli piszemy pakiet, zazwyczaj chcemy, żeby działał. Nie mogę być pewny, ale to chyba rozsądne założenie. Zazwyczaj pierwszym krokiem jest ręczne sprawdzenie, czy wszystko działa, jak byśmy się tego spodziewali. Żeby uzyskać dostęp do swoich funkcji tu i teraz, używamy komendy `devtools::load_all()`.\n\nZestaw podstawowych czynności w kierunku sprawdzenia, czy nie występują podstawowe problemy z naszym kodem, czy czegoś nie zepsuliśmy, nie dopilnowaliśmy, jest zautomatyzowany i nazywa się R-CMD-check. Muszą go przejść wszystkie pakiety obecne w CRAN. Jeśli wykonaliśmy instrukcję z podrozdziału [-@sec-GitHubActions], po każdym commicie wykona go również GitHub i wynik pokaże na odznace.\n\nPo pierwsze R-CMD-check sprawdzi, czy cały kod spełnia standardy, czyli czy wszystkie obiekty w kodzie mają globalne definicje (por. podrozdział [-@sec-cran-checks]), czy wszystkie przykłady wykonują się bez błędu, czy każda funkcja ma wszystkie niezbędne elementy dokumentacji, czy wszystkie używane pakiety zostały dodane jako zależności. Po drugie wykonane zostaną wszystkie testy, które opisuję w podrozdziale [-@sec-tests]. Po trzecie, zostanie sprawdzona struktura repozytorium, czy nic się nie zepsuło, czy nie mamy jakichś plików, które nie powinny tam być. Do tego cała seria mniejszych lub większych rzeczy, które R może nam wytknąć jako błędy, ostrzeżenia lub informacje. Warto informacje wypluwane przez R-CMD-check przeczytać, bo są bardzo konkretne. Błędów być nie może, ostrzeżeń lepiej, żeby nie było, rzeczy wytykane w informacjach poprawiamy, kiedy mamy czas (albo gdy chcemy wysłać pakiet do CRAN).\n\nŻeby wykonać R-CMD-check używamy komendy `devtools::check()`. Ta komenda na wstępie odnowi nam doumentację, więc jeśli jej używamy, to nie musimy już korzystać z `devtools::document()`. Informacje o przeprowadzanych testach wyświetlają się na bieżąco, ale jeśli pojawią się jakieś uchybienia, zostaną one zbiorczo wyświetlone na koniec. Komendę `devtools::check()` dobrze jest wykonać przed każdym wypchnięciem do GitHuba, żeby nie zdziwił nas wynik wykonany już w repozytorium.\n\n# Sprawdzanie wejścia i informacje o błędach\n\nTen podrozdział i wszystkie kolejne, **nie są niezbędne**, żeby pakiet działał i był użyteczny. Są to rzeczy, które warto wiedzieć, ale przydadzą się przede wszystkim w pakietach dużych i/lub udostępnianych szerokiej publiczności. Małe pakiety albo użytkowane w wąskim gronie zazwyczaj nie potrzebują szerokiej kontroli wejścia czy złożonych informacji o błędach. Jedyne, nad czym bym się zastanowił, czy nie wprowadzać od początku, to testy z podrozdziału [-@sec-tests].\n\nDobre komendy są odporne, w tym znaczeniu, że zabezpieczają użytkownika przed nieprawidłowym wykorzystaniem. Debiloodporne, chciałoby się powiedzieć. Jeśli osoba popełnia błąd, na przykład podaje wektor zamiast ramki danych albo wskazuje kolumny, których nie ma, powinna dostać konkretną informację zwrotną (tj. błąd). Jeśli nie zabezpieczymy naszej funkcji przed nieprawidłowym wykorzystaniem, użytkownik dostanie informacje o błędach z funkcji, z których zbudowaliśmy naszą funkcję. Innymi słowy jeśli na przykład wykorzystujemy komendę `select()` i użytkownik pod kolumnę, która nie istnieje, zobaczy błąd wygenerowany w kolumnie `select()`. Czasem to dobrze, czasem to źle. Jeśli wykonujemy jakieś skomplikowane przekształcenia w naszej funkcji i gdzieś w środku wypłynie błąd, informacja o błędzie może po prostu nijak nie podpowiadać, co mogło ten błąd spowodować. Czasem jednak te informacje będą wystarczająco jasne, by nie musieć tworzyć ich samodzielnie.\n\nOgólnie dobrze jest zabezpieczać swoje funkcje, ale znowu -- to **nie jest konieczne, żeby pakiet działał**. To będziemy robić, jak będziemy mieli czas albo poważnie będziemy chcieli ulepszyć nasz pakiet do użytku innych. My zazwyczaj znamy nasze funkcje bardzo dobrze, więc zazwyczaj będziemy je poprawnie wykorzystywać.\n\nZazwyczaj to zabezpieczenie dotyczy sprawdzania wejścia, czyli czy to, co użytkownik podał, spełnia wymogi naszej funkcji. Zazwyczaj robi się to na samym początku, dość prosto, bo za pomocą połączenia `if` i `stop()`. My tutaj jednak wykorzystamy ładniejsze informacje o błędach, które wdraża pakiet `cli` w połączeniu z `glue`. Oba te pakiety dodaliśmy już do zależności, jeśli wykorzystaliśmy `usethis::use_tidy_dependencies()`. Rodzina funkcji, które nam się tu przydadzą, to `cli::cli_abort()`, `cli::cli_warn()` lub `cli::cli_inform()`.\n\n## Typ argumentu\n\nZazwyczaj najpierw sprawdzamy, czy obiekt podany przez użytkownika jako argument ma odpowiedni typ. Na przykład jeśli naszym pierwszym argumentem jest ramka danych `df`, możemy chcieć upewnić się, czy to rzeczywiście jest ramka danych.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwinda_do_nieba <- 2 + 1 # coś, co nie jest ramką danych\n\ninput_check <- function(df) {\n    if (!is.data.frame(df)) {\n        cli::cli_abort(\n            c(\n                \"{.arg df} must be a data frame.\",\n                \"x\" = \"Provided {.arg df} is {.obj_type_friendly {df}}\"\n            )\n        )\n    }\n}\n\ninput_check(winda_do_nieba)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `input_check()`:\n! `df` must be a data frame.\n✖ Provided `df` is a number\n```\n:::\n:::\n\n\nKlamra `if` sprawdza, czy `df` *nie jest* ramką danych (zwróćmy uwagę na wykrzyknik `!`). Jeśli nie jest, uruchamiana jest funkcja `cli_abort()`. Zatrzymuje ona wykonywanie kodu i pokazuje w konsoli błąd w estetycznej formie.\n\nJak używać tej funkcji? Ma ona całkiem sporo możliwości. Najprostszą rzeczą, którą może przyjąć, jest sam komunikat z błędem. Może to być zwykły tekst. Mamy też dodatkowe możliwości formatowania, o których jednak później. Komunikat jest opatrzony ikonką, która zależy od tego, czy chcemy wyrzucić błąd, ostrzeżenie czy informację.\n\n## Punktory\n\nMożemy jednak dokładać kolejne komunikaty i kolejne ikonki. W takim wypadku do funkcji `cli_abort()` wrzucamy wektor komunikatów. Pierwszy komunikat jest nienazwany, zaś w kolejnych wprost wskazujemy, jakie chcemy punktory. Cała lista dostępna jest w [dokumentacji `cli::cli_bullet()`](https://cli.r-lib.org/reference/cli_bullets.html). Dostępne w chwili, gdy to piszę, pokazuję niżej.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncli::cli_bullets(\n    c(\n        \"bez wcięcia\",\n        \" \" = \"wcięcie\",\n        \"*\" = \"punktor\",\n        \">\" = \"strzałka\",\n        \"v\" = \"sukces\",\n        \"x\" = \"zagrożenie\",\n        \"!\" = \"ostrzeżenie\",\n        \"i\" = \"informacja\"\n    )\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nbez wcięcia\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n  wcięcie\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n• punktor\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n→ strzałka\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n✔ sukces\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n✖ zagrożenie\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n! ostrzeżenie\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nℹ informacja\n```\n:::\n:::\n\n\n## Formatowanie z `glue`\n\nPoza punktorami możemy dodatkowo formatować tekst korzystając ze składni dostarczanej przez `glue`. `cli` obsługuje ją automatycznie. Wszystkie szczegóły oraz jak to wygląda rzeczywiście w konsoli znajdziemy na [tej](https://cli.r-lib.org/reference/inline-markup.html) stronie dokumentacji. Ja omówię tutaj same podstawy. Jeśli chodzi o to, jak formatować, jak to powinno wyglądać, osobiście często sprawdzam w `tidyverse`. Próbuję wywołać podobny błąd np. w funkcji `dplyr::select()` i patrzę, co mi wyskakuje. Traktuję to jako wzorzec, podpowiedź.\n\nTekst, który chcemy sformatować, bierzemy w nawiasy klamrowe. W nawiasie zaczynamy od określenia, w jaki sposób chcemy dany tekst sformatować. Poniżej lista możliwych formatów.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncli_li(\"Tekst {.emph kursywą}.\")\ncli_li(\"{.strong Pogrubiony} tekst.\")\ncli_li(\"Fragment kodu: {.code sum(a) / length(a)}.\")\ncli_li(\"Nazwa pakietu: {.pkg cli}.\")\ncli_li(\"Nazwa funkcji: {.fn cli_text}.\")\ncli_li(\"Klawisz: wciśnij {.kbd spację}.\")\ncli_li(\"Nazwa lub ścieżka pliku: {.file /usr/bin/env}.\")\ncli_li(\"Adres mailowy: {.email marylala@marylarodowicz.pl}.\")\ncli_li(\"Adres WWW: {.url https://example.com}.\")\ncli_li(\"Zmienna środowiskowa: {.envvar R_LIBS}.\")\ncli_li(\"Typ obiektu: `mtcars` is {.obj_type_friendly {mtcars}}\")\n```\n:::\n\n\nJeśli chcemy, możemy wykonywać też operacje w nawiasach klamrowych. Zazwyczaj będziemy wtedy zagnieżdżać jedne nawiasy w drugich. Najlepiej pokazać to na przykładzie.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncli_warn(\"Złamano {.strong {sum(365, 248)}} postanowień. Ostrzegam cię.\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Złamano 613 postanowień. Ostrzegam cię.\n```\n:::\n:::\n\n\nWewnątrz klamry z pogrubieniem dołożyłem drugą klamrę, w której umieściłem funkcję sumującą. Umieszczenie funkcji w klamrze sprawiło, że w ostrzeżeniu pojawia nam się wynik, 613, a nie tekst `sum(365, 248)`. Nie jest to zbyt użytkowy przykład, ale dobrze jest wiedzieć, że tak się da. W kolejnym przykładzie zobaczymy, jak można tego użyć do dostosowywania informacji zwrotnych pod użytkownika.\n\n## Obecność kolumn w bazie\n\nPoza sprawdzeniem typu argumentu, możemy chcieć się upewnić, że kolumny wskazane przez użytkownika rzeczywiście są obecne w bazie. Pomocna będzie tutaj funkcja `rlang::has_name()`, która dokładnie to sprawdza. Jeśli obiekt istnieje, `has_name()` wyrzuca `TRUE`, a jeśli nie, wyrzuca `FALSE`. Niestety `has_name()` wymaga nazwy kolumny w postaci string, dlatego musimy pobawić się trochę z Tidy Eval. Jeśli nie wiesz, jak to robić, odsyłam do [tego](./posts/metaprogramowanie.qmd) tekstu.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncol_check <- function(df, id_column) {\n    id_column <- enquo(id_column)\n\n    if (!rlang::has_name(df, rlang::as_name(id_column))) {\n        cli::cli_abort(\n            c(\n                \"All columns must exist in the data.\",\n                \"x\" = \"Column {.var {rlang::as_name(id_column)}} does not exist.\",\n                \"i\" = \"Check the spelling.\"\n            )\n        )\n    }\n}\n\ncol_check(iris, Sepal.Density)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `col_check()`:\n! All columns must exist in the data.\n✖ Column `Sepal.Density` does not exist.\nℹ Check the spelling.\n```\n:::\n:::\n\n\nW powyższym przykładzie widzimy też, do czego może nam się przydać zagnieżdżanie nawiasów klamrowych. Tutaj wykorzystuję je do zawarcia nazwy nieistniejącej kolumny w komunikacie o błędzie.\n\n# Testy z `testthat` {#sec-tests}\n\nTesty automatyczne to bardzo szeroki temat. Idea, która za nimi stoi, jest mniej więcej taka -- jest wiele rzeczy, które mogą pójść źle, które można zepsuć. Nikomu się nie chce po każdych zmianach w kodzie sprawdzać, czy jakiś drobny aspekt przez te zmiany nie ucierpiał. W tym celu piszemy specjalne skrypty, które za nas sprawdzą, czy wszystko działa tak, jak powinno. W R testy piszemy z użyciem pakietu `testthat`. By móc z niego korzystać, uruchamiamy w naszym repozytorium komendę `usethat::use_testthat()`.\n\n## Struktura testów\n\nWszystkie testy znajdują się w folderze `tests`, w podfolderze `testthat`. Możemy je wytwarzać ręcznie, ale zazwyczaj będziemy wykorzystywać komendę `usethis::use_test()`. W domyśle jeden plik z funkcjami powinien mieć odpowiadający mu plik z testami. W RStudio komenda `usethis::use_test()` nie potrzebuje żadnych argumentów -- domyślnie tworzy plik z testami dla aktualnie otwartego skryptu.\n\nNowo utworzony plik zawiera przykładowy test, który możemy spokojnie usunąć. Żeby napisać własny test wykorzystamy przede wszystkim komendę `test_that()` oraz komendy z rodziny `expect_*()`. Komenda `test_that()` przyjmuje dwie rzeczy -- opis, co test robi (jako string) oraz komendy składające się na test zapisane w nawiasach klamrowych. Warto zauważyć, że nie musimy pisać `testthat::test_that()`. Cały pakiet jest dostępny od chwili użycia `usethat::use_testthat()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_that(\"Jakiś element działa jak należy\", {\n    # Tutaj komendy składające się na test\n})\n```\n:::\n\n\nW nawiasach klamrowych możemy zapomnieć, że jesteśmy wewnątrz funkcji i pisać kod normalnie. Możemy na przykład tworzyć przykładowe zbiory danych, na których będziemy wykonywać testy. Najważniejsze są jednak funkcje z rodziny `expect_*()`, za pomocą których mówimy, czego oczekujemy od danej funkcji. Rodzina ta jest szeroka, bo i funkcje do testowania są bardzo różne. W ramach jednej funkcji `test_that()` możemy użyć kilku tego typu komend, ale staramy się utrzymać porządek, żeby każda funkcja `test_that()` testowała coś konkretnego. Poniżej wymieniam kilka najważniejszych funkcji `expect_*()`, a bardziej rozszerzoną ich listę można znaleźć [tutaj](https://testthat.r-lib.org/reference/).\n\n1.  `expect_identical()` i `expect_equal()` -- czy zadane wartości są takie same? Można ustawić tolerancję błędu.\n\n2.  `expect_length()` -- czy obiekt ma określoną długość?\n\n3.  `expect_names()` -- czy nazwy kolumn (wartości) są takie, jakie mają być? Pozwala zignorować kolejność i wielkość liter.\n\n4.  `expect_match()` -- czy w wektorze tekstowym jest tekst odpowiadający [wyrażeniu regularnemu](./posts/regex.qmd)?\n\n4. `expect_type()` -- czy obiekt jest określonego typu?\n\n6.  `expect_error()`, `expect_warning()` i `expect_message()` -- jak nazwa wskazuje; czy dany kod generuje błąd/ostrzeżenie/informację? Pozwala też sprawdzać treść komunikatów za pomocą [wyrażeń regularnych](./posts/regex.qmd).\n\n7.  `expect_true()` i `expect_false()` -- najbardziej uniwersalne funkcje sprawdzające. Jednocześnie lepiej zastąpić je innymi, jeśli jest możliwość, żeby wyniki testów były bardziej czytelne.\n\n## Przykładowe testy\n\nZałóżmy, że chcemy napisać testy do naszej funkcji `opisowe()`. Przypomnijmy jej definicję.\n\n\n::: {.cell filename='opisowe.R'}\n\n```{.r .cell-code}\nopisowe <- function(df, group, ...) {\n    # check if df is a dataframe\n    if (!is.data.frame(df)) {\n        cli::cli_abort(\n            c(\n                \"{.arg df} must be a data frame.\",\n                \"x\" = \"Provided {.arg df} is {.obj_type_friendly {df}}\"\n            )\n        )\n    }\n\n    kolumny_do_policzenia <- enquos(...)\n\n    df %>%\n        group_by({{ group }}) %>%\n        summarise(\n            across(\n                c(!!!kolumny_do_policzenia),\n                .fns = list(\n                    N = \\(x) sum(!is.na(x)),\n                    M = \\(x) mean(x, na.rm = TRUE),\n                    SD = \\(x) sd(x, na.rm = TRUE),\n                    A = agricolae::skewness,\n                    K = agricolae::kurtosis,\n                    `NA` = \\(x) sum(is.na(x))\n                )\n            )\n        )\n}\n```\n:::\n\n\nDorzuciłem tutaj sprawdzenie, czy `df` jest ramką danych. Jakie testy moglibyśmy napisać dla tej funkcji? Poniżej kilka przykładów.\n\n\n::: {.cell filename='test-opisowe.R'}\n\n```{.r .cell-code}\n# create a test data frame with normally distributed data\nset.seed(123)\ndf <- data.frame(\n    group = rep(c(\"A\", \"B\"), each = 50),\n    x = rnorm(100, mean = 0, sd = 1),\n    y = rnorm(100, mean = 5, sd = 2)\n)\n\n# test if function returns a data frame\ntest_that(\"opisowe returns a data frame\", {\n    expect_s3_class(opisowe(df, group, x, y), \"data.frame\")\n})\n\n# test if function calculates summary statistics correctly\ntest_that(\"opisowe calculates summary statistics correctly\", {\n    result <- opisowe(df, group, x, y)\n    ## N\n    expect_equal(result$group, c(\"A\", \"B\"))\n    expect_equal(result$x_N, c(50, 50))\n    expect_equal(result$y_N, c(50, 50))\n    ## M\n    expect_equal(result$x_M, c(0.0344, 0.1464), tolerance = 0.001)\n    expect_equal(result$y_M, c(4.4921, 5.0776), tolerance = 0.001)\n    ## SD\n    expect_equal(result$x_SD, c(0.9258, 0.9054), tolerance = 0.001)\n    expect_equal(result$y_SD, c(1.9786, 1.8619), tolerance = 0.001)\n    ## A\n    expect_equal(result$x_A, c(0.1729, -0.0462), tolerance = 0.001)\n    expect_equal(result$y_A, c(0.4376, 1.0372), tolerance = 0.001)\n    ## K\n    expect_equal(result$x_K, c(-0.3366, 0.3234), tolerance = 0.001)\n    expect_equal(result$y_K, c(-0.1718, 1.8702), tolerance = 0.001)\n    ## NA\n    expect_equal(result$x_NA, c(0, 0))\n    expect_equal(result$y_NA, c(0, 0))\n})\n\n# test if function throws an error when df is not a data frame\ntest_that(\"opisowe throws an error when df is not a data frame\", {\n    expect_error(opisowe(list(), group, x, y))\n})\n```\n:::\n\n\nPo pierwsze stworzyłem tutaj bazę danych, na której będziemy liczyć. Po drugie stworzyłem trzy zestawy testów. Pierwszy sprawdza, czy wynik to ramka danych. Drugi sprawdza, czy statystyki wyglądają, jak mają wyglądać, z dokładnością do 3. miejsca po przecinku. Ostatni sprawdza, czy funkcja wyrzuca błąd, gdy `df` będzie czymś innym, niż baza danych.\n\nGdy taki plik zapiszemy, testy są już uzbrojone. Możemy je wykonać używając komendy `devtools::test_active_file()`. Wszystkie testy zostaną też wykonane podczas `devtools::check()`.\n\n## Co i jak testować?\n\nHot take, którego nie ma jeszcze w podręcznikach -- sztuczna inteligencja jest świetna w pisaniu testów. Nie ma się co oszukiwać, pisanie testów jest upierdliwe, ale na szczęście Chat GPT może to sprawnie zrobić za nas. Od Chatu GPT lepszy jest GitHub Copilot X, do którego dostęp studenci i pracownicy naukowi mają [za darmo](https://education.github.com/discount). Czasami tylko testy generowane przez AI wykorzystują wycofane już komendy, np. `expect_is()` zamiast `expect_type()`.\n\nTesty jest dobrze pisać, bo czasem możemy przegapić, że coś zepsuliśmy. Jeśli zabezpieczyliśmy się testami, `devtools::check()` nakrzyczy na nas, że coś zepsuliśmy. Nakrzyczy na nas też, jeśli nie wyjdą przykłady, ale przykład musi tylko zadziałać, a test może wymagać *konkretnego* wyjścia. Bez testów nie wykryjemy, że przykład zwraca bzdurę, bo jeśli zwraca cokolwiek, to R-CMD-check to wystarczy.\n\nSztuka polega na tym, żeby pisać testy tak, żeby nie trzeba było ich zmieniać za każdym jednym razem, jak będziemy coś zmieniać w funkcji. Zbyt duże struktury testów mogą sprawić, że kod będzie bardzo trudny do utrzymania. Małe poprawki mogą wymusić na nas każdorazowo szerokie zmiany w testach. Trzeba więc znaleźć jakiś punkt pośredni i nie dać się zwariować. Testy mają nam **oszczędzić pracy, a nie dołożyć**.\n\n# *Code coverage* z `codecov`\n\nZ testami wiąże się pojęcie *code coverage*. Jest to wskaźnik, który mówi o tym, jaki procent kodu jest sprawdzany w testach. Nie oznacza to, czy sprawdziliśmy wszystkie sytuacje, w których w kodzie może zadziać się coś źle, ale czy każda linia kodu została wykonana w testach chociaż raz. A więc, czy na bardzo podstawowym poziomie działa, czyli czy wykonuje się bez błędu.\n\n## Sprawdzanie *code coverage*\n\n*Code coverage* możemy bardzo łatwo sprawdzić zarówno dla pojedynczego pliku, jak i dla całego pakietu. Robią to odpowiednio funkcje `devtools::test_coverage_active_file()` i `devtools::test_coverage()`. Raport z takiego sprawdzenia zawiera ogólny *code coverage*, także w podziale na pliki oraz informację, jakie konkretne linijki zostały, a jakie nie zostały przetestowane.\n\n![Wynik `devtools::test_coverage()`.](ilustracje/pakiety-w-R/covr.png)\n\n## Automatyczne raportowanie\n\nIstnieje cała seria narzędzi do automatycznego raportowania *code coverage*. Bardzo często repozytoria chwalą się wielkością tego wskaźnika na odznakach. Jeśli pakiet jest dobrze testowany, to może znaczyć, że jest porządnie zrobiony albo chociaż z należytą dbałością.\n\nNarzędziem, które tutaj omówię i które ma dobrą integrację z R, jest Codecov. Żeby podłączyć swoje repozytorium do Codecov musimy założyć odpowiednie konto i uruchomić dwie komendy. Jeśli chodzi o konto, wchodzimy na [codecov.io](https://codecov.io/), zakładamy konto i upoważniamy Codecov do dostępu do naszego konta GitHub. Naszym oczom powinna ukazać się lista wszystkich naszych repozytorów, do której wkrótce wrócimy. Komendy natomiast wymieniam niżej.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_coverage(\"codecov\")\nusethis::use_github_action(\"test-coverage\")\n```\n:::\n\n\nPrzygotuje to nasze repozytorium, ale nie w sposób idealny. W momencie, w którym to piszę, trzeba wprowadzić serię poprawek i dodatkowych czynności, żeby wszystko szło, jak powinno.\n\n1. Na stronie [codecov.io](https://codecov.io/) wchodzimy w nasze repozytorium i kopiujemy token, który się tam wyświetla. Musimy go wskazać w naszym repozytorium jako sekret. Robimy to w ustawieniach repozytorium, ale szczęśliwie Codecov podpowiada nam link bezpośrednio do ustawień. Nazwa sekretu to `CODECOV_TOKEN`, a jego wartość to sam ten kod, który skopiowaliśmy.\n\n2.  Jeśli chcemy, możemy upoważnić [apkę Codecov na GitHubie](https://github.com/apps/codecov). Zamieszcza ona automatyczne raporty o *code coverage* przy pull requestach.\n\n3. Plik `.github/workflows/test-coverage.yaml` modyfikujemy w taki sposób, żeby góra tego pliku wyglądała tak, jak niżej. Nie usuwamy innych zmiennych środowiskowych, tylko dopisujemy `CODECOV_TOKEN`.\n\n```\njobs:\n  test-coverage:\n    runs-on: ubuntu-latest\n    env:\n      CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}\n```\n\n4.  Jeśli repozytorium jest prywatne, na końcu zmieniamy naszą formułę tak, żeby wyglądała jak niżej.\n\n```\n- name: Upload coverage reports to Codecov\n  uses: codecov/codecov-action@v3\n  with:\n    token: ${{ secrets.CODECOV_TOKEN }}\n```\n\n5.  Odznaka dodawana przez `usethis` nie działa. Na [codecov.io](https://codecov.io/), po wejściu w nasze repozytorium (już po jego uruchomieniu), w ustawieniach, w sekcji „Badges & Graphs\" znajdziemy poprawny link, którym zastępujemy ten dodany przez `usethis` w `README.Rmd`.\n\nZestaw określony wyżej może się dość szybko zdezaktualizować, dotarłem do niego na zasadzie prób i błędów. Najbardziej newralgiczne są punkty 3. i 4., które mają za zadanie dać Codecov znać, jaki jest token, który dodaliśmy wcześniej do sekretów repozytorium. Po wykonaniu tych czynności raporty *code coverage* staną się jawne, będziemy mogli się nimi chwalić na głównej stronie naszego repozytorium, a także będą wykonywane automatycznie przez GitHub za każdym razem, gdy wypchniemy nowy commit.\n\n# Bonus: załączanie apki w Shiny\n\nNie wiem, ile osób będzie tego potrzebować, ale że ciężko mi było to znaleźć, to się podzielę. Jak załączyć do naszego pakietu apkę napisaną w Shiny? Miałem ten problem, gdy chciałem dołączyć GUI do pakietu `mtscr`, które napisałem właśnie w Shiny.\n\n1.  W folderze `inst` tworzymy podfolder o wybranej przez nas nazwie. Jako przykład wybiorę podfolder `GUI`.\n\n2.  Do podfolderu wrzucamy naszą apkę w Shiny, ale główny plik koniecznie nazywamy `app.R`.\n\n3.  W głównym pakiecie tworzymy funkcję uruchamiającą. Przykład niżej. Zamiast `\"GUI\"` piszemy nazwę naszego podfolderu, a zamiast `\"mtscr\"` nazwę naszego pakietu. Przykładowa funkcja sprawdza tylko, czy apka znajduje się tam, gdzie powinna. Funkcja `system.file` zwraca ścieżkę do pakietu, a w tym wypadku do konretnego komponentu tego pakietu -- apki w Shiny.\n\n\n::: {.cell filename='mtscr_app.R'}\n\n```{.r .cell-code}\nmtscr_app <- function() {\n    app_dir <- system.file(\"GUI\", package = \"mtscr\")\n    if (app_dir == \"\") {\n        cli::cli_abort(\n            c(\n                \"The app not found.\",\n                \"i\" = \"Try reinstalling the {.pkg mtscr} package with {.run devtools::intall_github(\\\"jakub-jedrusiak/mtscr\\\")\"\n            )\n        )\n    }\n    shiny::runApp(app_dir, display.mode = \"normal\")\n}\n```\n:::\n\n\nUżytkownik może teraz bez problemu uruchomić naszą apkę w Shiny poprzez funkcję uruchamiającą. Warto też pomyśleć, czy nie zrobić z niej dodatku do RStudio. Możemy to zrobić tworząc plik `inst/rstudio/addins.dcf` i dopisując do niego coś w tym rodzaju.\n\n\n::: {.cell filename='addins.dcf'}\n\n```{.r .cell-code}\nName: MTSCR GUI\nDescription: Runs MTSCR GUI app.\nBinding: mtscr_gui # funkcja uruchamiająca\nInteractive: true # dla Shiny dajemy true\n```\n:::\n\n\nOd tego momentu `MTSCR GUI` będzie dostępne w menu *addins* w RStudio.\n\n# Podsumowanie\n\nDocieramy wreszcie do końca tego przydługiego tekstu. Jak zwykle, tylko liznęliśmy temat po powierzchni, ale mam nadzieję, że było to wystarczające liźnięcie, żeby poczuć smak budowania pakietów. Przede wszystkim liczę na to, że wystarczy to, by móc dalej samodzielnie zdobywać wiedzę w już konkretnych zakresach. Podstawowe źródła to, jak zwykle, dokumentacja i książka Hadleya Wickhama. Tym razem tą książką jest [R Packages](https://r-pkgs.org/) i jest tam większość tego, co można znaleźć w tym tekście, tylko znacznie, znacznie pogłębione.\n\nOprócz podsumowania w punktach wydaje mi się, że korzystne będzie zebranie wszystkich podstawowych komend w zestawy tematyczne. Zestawy ułożyłem chronologicznie, to znaczy w takiej kolejności, w jakiej będziemy budować nasz pakiet.\n\n## Zakładanie repozytorium\n\n\n::: {.cell}\n\n```{.r .cell-code}\nroxygen2::roxygenise() # dodaj roxygen2, najpeirw usuń NAMESPACE\nusethis::use_roxygen_md() # obsługa markdown w roxygen2\nusethis::use_gpl3_license() # licencja GPL v. 3\nusethis::use_package(\"R\", type = \"Depends\", min_version = \"4.2.0\") # dodaj zależność od R\nusethis::use_tidy_dependencies() # podstawowe zależności tidyverse\nusethis::use_tidy_eval() # narzędzia do Tidy Eval\nusethis::use_tibble() # dodaj tibble\nusethis::use_pipe() # dodaj potoki z magrittr %>%\nusethis::use_lifecycle() # dodaj oznaczniki lifecycle\nusethis::use_readme_rmd() # dodaj README.Rmd\n```\n:::\n\n\n## Podłączanie GitHuba\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_git() # popraw/załóż pliki repozytorium git\nusethis::use_github(private = TRUE) # załóż repozytorium prywatne na GitHubie\nusethis::use_github_action_check_standard() # dodaj automatyczne R-CMD-check\n```\n:::\n\n\n## Mniejsze opcje\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_package_doc() # dokumentacja całego pakietu\nusethis::use_cran_badge() # odznaka CRAN\nusethis::use_lifecycle_badge(\"experimental\") # odznaka lifecycle experimental\nusethis::use_citation() # dodaj plik CITATION\n```\n:::\n\n\n## Testy\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndevtools::load_all() # załaduj pakiet, żeby testować ręcznie\nusethat::use_testthat() # dodaj testthat\nusethis::use_coverage(\"codecov\") # dodaj codecov\nusethis::use_github_action(\"test-coverage\") # dodaj automatyczne raporty codecov\n```\n:::\n\n\n## Używanie na co dzień\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndevtools::load_all() # załaduj pakiet, żeby testować ręcznie\nusethis::use_r(\"nazwa_funkcji\") # stwórz plik z funkcjami\nusethis::use_test() # dodaj plik z testami\nusethis::use_data_raw(\"nazwa bazy\") # stwórz plik z danymi\n```\n:::\n\n\n## Konserwacja\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndevtools::document() # zaktualizuj dokumentację\ndevtools::load_all() # załaduj pakiet\ndevtools::check() # zrób R-CMD-check\ndevtools::test_coverage() # sprawdź code coverage\ndevtools::build_readme() # zaktualizuj README.md\nstyler:::style_active_pkg() # formatuj wszystkie pliki w pakiecie\n```\n:::\n\n\n## Błędy\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncli::cli_abort(\"Treść błędu\") # błąd\ncli::cli_warn(\"Treść ostrzeżenia\") # ostrzeżenie\ncli::cli_inform(\"Treść infromacji\") # informacja\n```\n:::\n\n\n## Przed każdym wypchnięciem\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndevtools::load_all() # załaduj pakiet, żeby testować ręcznie\ndevtools::check() # zrób R-CMD-check\ndevtools::test_coverage() # sprawdź code coverage\ndevtools::build_readme() # zaktualizuj README.md\n```\n:::\n\n\n## Inne rzeczy do wykonania\n\n1.  Uzupełnij ręcznie plik `DESCRIPTION`. Pamiętaj o tym, by autorów wskazywać funkcją.\n\n2.  Uzupełnij plik `CITATION`, jeśli z niego korzystasz.\n\n3.  Napisz porządny plik `README`.\n\n4.  Pamiętaj o pisaniu pełnych nazw funkcji i używaniu `.data` do nazw kolumn bez cudzysłowu.\n\n5.  Każdą funkcję dokumentuj szkieletem `roxygen2`. Nie zapomnij o tagu `@export`.\n\n6.  Jeśli dodajesz pliki z danymi, pamiętaj, żeby je udokumentować w pliku `data.R`. Opisz wszystkie kolumny za pomocą `@format`.\n\n7.  Jeśli masz czas i chęć, zabezpieczaj funkcje przed nieprawidłowym wykorzystaniem. Przede wszystkim sprawdzaj typy argumentów oraz czy kolumny istnieją w bazie. Pamiętaj, że możesz formatować komunikaty o błędach.",
    "supporting": [
      "pakiety-w-R_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}