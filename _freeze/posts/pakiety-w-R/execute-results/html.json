{
  "hash": "1fa4d9c96f2822fdba65cc006cf47040",
  "result": {
    "markdown": "---\ntitle: \"Tworzenie pakietów w R\"\ndescription: \"Po co pisać własne pakiety w R? Widzę dwa powody. Po pierwsze możemy mieć pewną kolekcję funkcji, których często używamy w różnych analizach. Możemy je w pewnym momencie chcieć zebrać w jedno miejsce. Po drugie możemy chcieć się podzielić naszym kodem. W obu przypadkach pakiet jest lepszą, bardziej uporządkowaną i łatwiejszą w używaniu opcją niż pliki ze skryptami.\"\nimage: ./headers/pakiety-w-R.webp\ntwitter-card:\n    image: \"/headers/pakiety-w-R.webp\"\ncategories:\n    - R\ndraft: true\n---\n\n\n\n\nPakiety to nic innego jak zbiory funkcji. Od zwykłych plików .R z funkcjami różnią się tym, że mają określoną strukturę, dzięki której można je potem zainstalować i szybko wykorzystywać. Pewnie pierwszym skojarzeniem z pisaniem pakietów jest udostępnianie ich w CRAN. Owszem, można to zrobić, ale można mieć też prywatne pakiety trzymane na GitHubie. Nie musimy zaraz wszystkiego robić na tip-top, żeby każdy na świecie wygodnie korzystał z naszych trzech funkcji.\n\n# Przygotowanie\n\nDo tworzenia pakietów wykorzystujemy inne pakiety. Najważniejszym z nich jest `devtools`, który ciągnie za sobą cały szereg innych pakietów typu `roxygen2`, `usethis` czy `testthat`. Możesz nawet mieć już zainstalowane `devtools`, bo to w jego skład wchodzi funkcja `install_github()`, dzięki której instalujemy pakiety z GitHuba[^1]. Jeśli nie masz jeszcze zainstalowanego pakietu `devtools`, zainstaluj go teraz.\n\n[^1]: Funkcje `install_*()` zapewnia też mniejszy pakiet `remotes`, który jest praktycznie wycinkiem z `devtools`. Jeśli mamy `devtools`, nie potrzebujemy `remotes`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"devtools\")\n```\n:::\n\n\nW tym tekście będę używał pełnych nazw funkcji, np. `usethis::use_readme_md()`. Jeśli jednak na początku pracy załadujesz `devtools`, nie musisz później podawać nazw pakietów.\n\nNajprostszym sposobem na utworzenie zrębu pakietu R jest wykorzystanie menu do tworzenia projektów w RStudio. Podczas tworzenia projektu możemy wybrać jego typ i nas interesuje *R package*. W wygodnym kreatorze wpisujemy nazwę pakietu. Warto też zaznaczyć, że chcemy mieć do tego repozytorium Git. Jeśli zabieramy się za tworzenie pakietu, powinniśmy umieć choć w podstawowym stopniu korzystać z Gita. Jeśli nie znasz Gita, zachęcam do przeczytania [tego posta](./posts/git.qmd).\n\n![](ilustracje/pakiety-w-R/RStudio-wizard.png)\n\n# Struktura pakietu {#sec-structure}\n\nStworzony przez nas zręb pakietu już ma określoną strukturę. W folderze z pakietem znajdziemy serię szczególnych plików i folderów, która potem będzie się wzbogacać. Obecnie są to:\n\n-   `.gitignore` -- plik repozytorium mówiący, co Git ma ignorować (więcej o tym w [tekście o Git](./posts/git.qmd)).\n\n-   `.Rbuildignore` -- plik, w którym podajemy niestandardowe pliki z folderu z pakietem; jest to ważne, bo R-CMD-check (o którym później) będzie na nas krzyczał, jeśli znajdzie niestandardowe pliki.\n\n-   `DESCRIPTION` -- metadane naszego pakietu, przede wszystkim nazwa, wersja, autorzy i wymagane inne pakiety.\n\n-   `man` -- folder z plikami .Rd z dokumentacją naszych funkcji; nie edytujemy ich ręcznie.\n\n-   `NAMESPACE` -- plik z przestrzenią nazw naszego pakietu; nie edytujemy go ręcznie.\n\n-   `R` -- folder, do którego wrzucamy pliki .R z naszymi funkcjami; najważniejsza część naszego pakietu.\n\nDo tego jeszcze znajdziemy tam plik z projektem RStudio. W miarę budowania naszego pakietu, nasz folder będzie się zaludniał nowymi plikami i folderami.\n\nJuż teraz warto jest uruchomić kilka komend z pakietu `usethis`, które ułatwią nam robotę w przyszłości. Są to funkcje, których zazwyczaj używamy tylko raz.\n\nPo pierwsze musimy przygotować nasz pakiet do używania `roxygen2`, czyli specjalnego standardu generującego dokumentację naszych funkcji, żebyśmy nie musieli ręcznie babrać się z plikami .Rd. Zaczynamy więc od **usunięcia pliku `NAMESPACE`**. Dlaczego? Bo nasz plik ma stworzyć `roxygen2`, a nie RStudio. Następnie używamy komendy `roxygen2::roxygenise()`. Doda ona do pliku `DESCRIPTION` informację o używanej wersji `roxygen2` oraz stworzy nowy plik `NAMESPACE`. Następnie używamy komendy `usethis::use_roxygen_md()`[^2]. Pozwoli ona używać nam wygodnej składni markdown w dokumentacji, np. \\*\\***bold**\\*\\* wygeneruje nam pogrubiony tekst.\n\n[^2]: Jeśli już wcześniej stworzyłeś(-aś) jakieś pliki z funkcjami i je udokumentowałeś(-aś), to użyj teraz `roxygen2md::roxygen2md()`, by przerobić je na nowy standard. Jeśli tworzysz pakiet po kolei zgodnie z tym wpisem, nie ma takiej potrzeby.\n\n# `DESCRIPTION`\n\nPlik `DESCRIPTION`, jak już wspomniałem, to opis naszego pakietu. Jeśli otworzymy go teraz, zobaczymy przygotowany wcześniej szkielet. Możemy teraz uzupełnić tytuł, wersję i opis. Jeśli opis zajmie więcej niż linijkę, kolejne linijki powinny zaczynać się wcięciem 4 spacji.\n\n## Autorzy\n\nJeśli chodzi o autorów pakietu, podajemy ich w dość specyficzny sposób. Najpierw jednak kasujemy całą linijkę `Maintainer`. To stary standard, którego lepiej unikać. Spójrzmy na przykład.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nAuthors@R: person(\n      \"Jakub\", \"Jędrusiak\",\n      email = \"kuba23031999@gmail.com\",\n      role = c(\"aut\", \"cre\"),\n      comment = c(\n        ORCID = \"0000-0002-6481-8210\",\n        affiliation = \"University of Wrocław\"\n        )\n      )\n```\n:::\n\n\nPo pierwsze `Author` zmieniamy na `Authors@R` i to niezależnie od liczby autorów. Jeśli autor jest jeden, podajemy go za pomocą funkcji `person()`. Podstawowe informacje to imię w pierwszym argumencie[^3], nazwisko w drugim. Tych argumentów nie musimy nazywać. Dalej mamy inne informacje, które już nazwać warto. `email` jaki jest, każdy widzi. `role` to opis funkcji osoby w tworzeniu pakietu. Używamy tutaj kodów opisanych w dokumentacji funkcji `person()`. Kilka podstawowych kodów ról wymieniam w tabeli poniżej. Jak widać w przykładzie, każda osoba może mieć więcej niż jedną rolę. Dalej mamy `comment`, który zawsze podajemy w postaci nazwanego wektora. Podstawowym, co możemy tam wrzucić, jest numer ORCiD oraz afiliacja.\n\n[^3]: Jeśli chcemy podać dwa imiona, podajemy je jako wektor, np. `c(\"Paweł\", \"Przemysław\")`.\n\n| Kod     | Funkcja            | Opis                                                                                                 |\n|---------|--------------------|------------------------------------------------------------------------------------------------------|\n| `\"aut\"` | *Author*           | Pełny autor, wszystkie osoby, które powinny pojawić się w cytowaniu powinny mieć przypisaną tę rolę. |\n| `\"cre\"` | *Creator*          | Osoba odpowiedzialna za dbanie o kod w pakiecie, *maintainer*.                                       |\n| `\"ctb\"` | *Contributor*      | Osoby, które wniosły wkład w pakiet, ale nie powinny pojawiać się w cytowaniu.                       |\n| `\"cph\"` | *Copyright holder* | Osoba lub instytucja posiadająca prawa autorskie do pakietu.                                         |\n\nJeśli autorów jest więcej niż jeden, podajemy ich w postaci wektora. Poniżej przykład.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nAuthors@R: c(\n    person(\n      \"Boris\", \"Forthmann\",\n      email = \"boris.forthmann@uni-muenster.de\",\n      role = \"aut\",\n      comment = c(\n        ORCID = \"0000-0001-9755-7304\",\n        affiliation = \"University of Münster\"\n      )\n    ),\n    person(\n      \"Maciej\", \"Karwowski\",\n      email = \"maciej.karwowski@uwr.edu.pl\",\n      role = \"aut\",\n      comment = c(\n        ORCID = \"0000-0001-6974-1673\",\n        affiliation = \"University of Wrocław\"\n      )\n    ),\n    person(\n      c(\"Roger\", \"E.\"), \"Beaty\",\n      email = \"rebeaty@psu.edu\",\n      role = \"aut\",\n      comment = c(\n        ORCID = \"0000-0001-6114-5973\",\n        affiliation = \"Pennsylvania State University\"\n        )\n      ),\n    person(\n      \"Jakub\", \"Jędrusiak\",\n      email = \"kuba23031999@gmail.com\",\n      role = c(\"aut\", \"cre\"),\n      comment = c(\n        ORCID = \"0000-0002-6481-8210\",\n        affiliation = \"University of Wrocław\"\n        )\n      )\n    )\n```\n:::\n\n\n## `CITATION`\n\nJeśli chcemy, by nasz pakiet był cytowany w jakiś konkretny sposób, możemy wprost go wskazać w pliku `CITATION`. Wytwarzamy go po uzupełnieniu koniecznych informacji w pliku `DESCRIPTION` za pomocą komendy `usethis::use_citation()`. Sam plik siedzi w folderze `inst`. Umieszczamy w nim informacje o cytowaniu w formacie BibTeX (każdy generator potrafi taką wytworzyć), a jeśli chcemy, to także wersję tekstową. Decyduje to o sposobie, w jaki wyświetla się wynik funkcji `citation()`. Poniżej przykładowy plik `CITATION`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncitHeader(\"To cite mtscr in publications use:\")\n\ncitEntry(\n  entry    = \"Manual\",\n  title    = \"Multidimensional Top Scoring for Creativity Research\",\n  author   = \"Boris Forthmann, Maciej Karwowski, Roger E. Beaty, Jakub Jędrusiak\",\n  year     = \"2023\",\n  url      = \"https://github.com/jakub-jedrusiak/mtscr\",\n  textVersion = paste(\n\"Forthmann, B., Karwowski, M., Beaty, R. E., Jędrusiak, J. (2023). Multidimensional Top Scoring for Creativity Research. Retrieved from: https://github.com/jakub-jedrusiak/mtscr\"\n  )\n)\n```\n:::\n\n\n## Licencja\n\nLicencji nie dodajemy do pakietu ręcznie. Używamy tutaj odpowiedniej funkcji z pakietu `usethis`, np. dla licencji MIT będzie to `usethis::use_mit_license()`, a dla GPL v.3 `usethis::use_gpl3_license()`. Pełną listę dostępnych licencji można znaleźć [tutaj](https://usethis.r-lib.org/reference/licenses.html). Jaką licencję wybrać? Najprościej mówiąc, MIT to *de facto* pójście we w pełni wolny kod. Taki kod może np. stać się częścią płatnego programu, ale prawa autorskie ciągle obowiązują. GPL natomiast wymusza, by programy oparte na naszym kodzie też były licencjonowane pod GPL, czyli by zawsze były darmowe. Większość pakietów R (ok. 70%) korzysta z licencji GPL.\n\n## Zależności {#sec-dependencies}\n\nNajperwniej nie będziemy pisać całego naszego kodu w podstawowym R, a raczej będziemy wykorzystywać inne pakiety. Żeby dodać jakiś pakiet jako zależność, używamy np. `usethis::use_package(\"rlang\", \"dplyr\")`. Nie należy nigdy podawać `tidyverse` jako zależności, a raczej konkretne pakiety typu `dplyr` czy `stringr`. Możemy przy tym wymusić wykorzystanie minimalnej wersji danego pakietu argumentem `min_version`, np. pisząc `usethis::use_package(\"dplyr\", min_version = \"1.1.0\")`. Jeśli zerkniemy w plik `DESCRIPTION` po uruchomieniu takiej komendy, zobaczymy, że dodane pakiety znalazły się w sekcji `Imports`. Tak powinno być. Istnieją jednak inne możliwe sekcje. Jeśli dodajemy pakiet, który nie jest potrzebny do działania naszych funkcji, ale na przykład potrzebujemy go do uruchomienia przykładów (bo chociażby wykorzystujemy w nich dane `diamonds` z pakietu `ggplot2`, podczas gdy nie wykorzystujemy samego `ggplot2` w naszych funkcjach), dodajemy go w sekcji `Suggests`. Robimy to pisząc na przykład `usethis::use_package(\"ggplot2\", type = \"Suggests\")`.\n\nIstnieje seria zależności, które posiada większość pakietów i które mają swoje własne funkcje w pakiecie `usethis`. Wymieńmy sobie te najważniejsze:\n\n1.  `usethis::use_pipe()` -- dodaje obsługę potoków `%>%` z pakietu `magrittr`.\n\n2.  `usethis::use_tibble()` -- dodaje obsługę `tibble` jako formy, w której nasze funkcje zwracają dane.\n\n3.  `usethis::use_tidy_dependencies()` -- standardowe zależności typu `rlang`, `cli` czy `glue`. Według mnie powinno się uruchamiać zawsze.\n\n4.  `usethis::use_tidy_eval()` -- podstawowe pakiety do [Tidy Eval](./posts/metaprogramowanie.qmd). Według mnie powinno się uruchamiać zawsze.\n\n5.  `usethis::use_lifecycle()` -- dodaje zależność od pakietu `lifecycle`, w którym możemy oznaczyć nasze funkcje jako eksperymentalne albo wycofane.\n\nDodatkowo większość pakietów posiada wprost wskazaną zależność od samego R. Taka zależność musi być w sekcji `Depends` i musi posiadać minimalną wersję co najmniej 3.5.0[^5]. W praktyce najlepiej jest podawać minimalną wersję 4.1.0, bo w tej wersji dodano natywny potok `|>`, a już w ogóle najlepiej nie cofać się przed 4.2.0, kiedy potoki wzbogacono o `_`, czyli informację, gdzie ma się znaleźć dany argument, jeśli nie na pierwszym miejscu (odpowiednik `.` w `magrittr`). \n\n[^5]: Jest to wymagane, jeśli wykorzystujemy pliki z danymi. Technicznie można dać niższą wersję, ale nie polecam.\n\n# `README`\n\nKażde repozytorium powinno mieć plik README, czyli opis, który wyświetli się na stronie pakietu na GitHubie. Gdy tworzymy pakiet R, mamy dwie możliwości, jakiego rodzaju plik README wytworzymy.\n\n1. `README.md` -- opcja klasyczna, wytwarza zwykły plik markdown.\n\n2. `README.rmd` -- opcja fajniejsza, wytwarza plik .Rmd, w którym możemy dorzucać przykładowy kod w R razem z jego efektami.\n\nPierwsza opcja wymaha użycia komendy `usethis::use_readme_md()`. Wytworzy ona zwykły plik .md, który możemy wypełnić korzystając z [instrukcji na GitHubie](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax). Jeśli chcemy zyskać dostęp do możliwości oferowanych przez RMarkdown, używamy `usethis::use_readme_rmd()`. Wytworzy to plik .Rmd, w którym możemy pokazać, na co stać nasz pakiet. Dokładny opis składni znajdziemy [tutaj](https://rmarkdown.rstudio.com/), zaś poniżej przykład.\n\n```` {.code-overflow-wrap}\nThe main function is `mtscr_scores()` which can return a df with scores for each participant, each item or each participant-item combination. Scores come from two models – `all_max` and `all_top2`. A value for a participant is the maximum value predicted by the model for that participant.\n\n```{{r}}\nlibrary(\"mtscr\")\ndata(\"mtscr_creativity\", package = \"mtscr\")\n```\n````\n::: {.light-mode}\n![Efekt działania kodu RMarkdown z ramki na GitHubie.](ilustracje/pakiety-w-R/Rmarkdown.png)\n:::\n\n::: {.dark-mode}\n![Efekt działania kodu RMarkdown z ramki na GitHubie.](ilustracje/pakiety-w-R/Rmarkdown_dark.png)\n:::\n\nJeśli zdecydujemy się na tę opcję, zawsze edytujemy plik `README.Rmd`. GitHub nie potrafi go jednak odczytać, dlatego przed wysłaniem naszych plików na serwer musimy przekonwertować plik `README.Rmd` do pliku `README.md`. Robimy to prostą komendą `devtools::build_readme()`. Komenda `usethis::use_readme_rmd()` dodatkowo dodaje specjalną przypominajkę, która nie pozwala nam zrobić commitu, jeśli zmienialiśmy plik `README.Rmd`, a go nie wyeksportowaliśmy.\n\nNa marginesie dodam, że RMarkdown jest powoli zastępowany przez bliźniaczy standard [Quarto](https://quarto.org/), ale w chwili, gdy to piszę, `usethis` [nie planuje go wdrażać](https://github.com/r-lib/usethis/issues/1671).\n\n## Odznaki\n\nBardzo często w repozytoriach znajdziemy odznaki. Są to elementy informacyjno-ozdobne, które mówią coś o naszym pakiecie, np. że przechodzi testy, że jest w CRAN albo ile razy w miesiącu ktoś go pobiera. Ciekawe odznaki obejmują:\n\n1. Odznakę `R-CMD-check`, o której piszę w podrozdziale [-@sec-GitHubActions].\n\n1. Odznakę `lifecycle`, którą możemy poinformować, że nasz pakiet jako całość jest eksperymentalny, stabilny lub wycofany. Możemy ją dodać wykorzystując komendę `usethis::use_lifecycle_badge(\"stable\")`. Argument wybieramy jaki chcemy.\n\n2. Odznakę CRAN, która informuje, jaka wersja naszego pakietu dostępna jest w CRAN. Jeśli pakiet nie jest dostępny, to odznaka też może o tym poinformować. Dodajemy ją komendą `usethis::use_cran_badge()`.\n\n::: {.light-mode}\n![Kilka odznak w nagłówku pliku README na GitHubie.](ilustracje/pakiety-w-R/badges.png)\n:::\n\n::: {.dark-mode}\n![Kilka odznak w nagłówku pliku README na GitHubie.](ilustracje/pakiety-w-R/badges_dark.png)\n:::\n\nTo nie jest obowiązkowa część pakietu, odznaki, ale piszę o tym, bo lubię takie ładne pierdółki. Inne odznaki znajdziemy na [shields.io](https://shields.io/), albo w R wykorzystując pakiet [`badger`](https://github.com/GuangchuangYu/badger).\n\n# GitHub\n\nZazwyczaj swoje pakiety chcemy trzymać na GitHubie[^4], żeby łatwo je instalować. Żeby podłączyć się do GitHuba, musimy użyć po kolei dwóch komend.\n\n[^4]: Jeśli nie wiesz, czym jest GitHub i po co go używać, przeczytaj [ten wpis](./posts/git.qmd).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_git()\nusethis::use_github(private = TRUE)\n```\n:::\n\n\nPierwsza dostosuje nasze repozytorium do ogólnych standardów. Druga podłączy nas do GitHuba, wytwarzając nowe repozytorium. Jeśli chcemy, by było prywatne, ustawiamy `private = TRUE`.\n\n## R-CMD-check na GitHubie {#sec-GitHubActions}\n\nKolejną polecaną przeze mnie czynnością, która powinna zostać wykonana w każdym repozytorium, jest uruchomienie tej komendy:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_github_action_check_standard()\n```\n:::\n\n\nDodaje ona kilka rzeczy. Po pierwsze sprawia ona, że po każdym naszym commicie GitHub wykonuje zestaw podstawowych testów zwanych R-CMD-check, o których więcej napiszę dalej. W drugiej kolejności dodaje ona odznakę R-CMD-check do naszego pliku README, żebyśmy mogli błyszczeć przechodzeniem testów.\n\n# Pliki z funkcjami\n\nPrzyszedł czas dodać jakieś rzeczywiste funkcje. Pisanie funkcji stanowiących część pakietu jest prawie identyczne jak pisanie zwyczajnych funkcji. Jak podam dalej, możemy chcieć postarać się bardziej i np. zabezpieczyć nasze funkcje przed błędami, ale znowu -- nie musimy. Podstawowe pułapki przy pisaniu własnych funkcji obejmują użeranie się z Tidy Eval, o którym piszę [tutaj](./posts/metaprogramowanie.qmd).\n\nŻeby dodać jakieś funkcje do swojego pakietu, użyj funkcji `usethis::use_r()`[^6], gdzie jako argument podasz nazwę pliku z funkcją. W większości przypadków będzie to nazwa samej funkcji. Możemy też zawrzeć kilka funkcji w jednym pliku, ale powinny być to bardzo blisko związane funkcje. Na tyle blisko związane, żeby mogły dzielić jedną stronę w dokumentacji. Przykładem takich funkcji może być na przykład rodzina `devtools::install_*()` albo `usethis::use_*_license()`. Wszystkie funkcje z tych zestawów są prawie identyczne, więc mogą być zgromadzone w jednym pliku.\n\n[^6]: Możesz też ręcznie wytworzyć odpowiedni plik .R w folderze `R`.\n\nNiezależnie jednak, czy robimy mały pakiecik do użytku własnego, czy może coś, co chcemy ostatecznie umieścić w CRAN, warto swoje funkcje udokumentować. Dokumentacja w R jest cudowna, łatwa w obsłudze i zawsze dostępna. Potraktuj swoją dokumentację jako ustrukturyzowane notatki, dzięki którym nie zapomnisz, na czym polegały Twoje funkcje i jak ich używać.\n\n## Specyficzne wymogi R-CMD-check\n\nZałóżmy, że napisaliśmy już własną funkcję, która liczy podstawowy zestaw statystyk opisowych i zwraca je w ulubionej przez nas formie. Na szczęście napisałem już taką funkcję w [tekście o metaprogramowaniu](./posts/metaprogramowanie.qmd).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nopisowe <- function(df, group, ...) {\n  kolumny_do_policzenia <- enquos(...)\n\n  df %>%\n    group_by({{ group }}) %>%\n    summarise(\n      across(\n        c(!!!kolumny_do_policzenia),\n        .fns = list(\n          N = \\(x) sum(!is.na(x)),\n          M = \\(x) mean(x, na.rm = TRUE),\n          SD = \\(x) sd(x, na.rm = TRUE),\n          A = agricolae::skewness,\n          K = agricolae::kurtosis,\n          `NA` = \\(x) sum(is.na(x))\n        )\n      )\n    )\n}\n```\n:::\n\n\nPonieważ jest to pakiet, musimy trochę dopasować naszą funkcję, jeśli nie chcemy, żeby R-CMD-check później na nas krzyczał. Jeśli nas to nie obchodzi, możemy to pominąć, ale lepiej jest od razu nabierać dobrych nawyków.\n\n1. Funkcje powinny być w postaci pełnych nazw, czyli np. `dplyr::group_by()`. Pakiety, z których pochodzą te funkcje, powinny być dodane jako zależności (por. podrozdział [-@sec-dependencies]). Jeśli użyliśmy `usethis::use_tidy_eval()` (por. podrozdział [-@sec-dependencies]), to funkcje z pakietu `rlang` są ładowane z automatu i nie potrzebują pełnych nazw.\n\n2. Jeśli w funkcjach typu `mutate()` wykorzystujemy kolumny istniejące w bazie, np. `mutate(iris, milimeters = Sepal.Length * 10)`, R-CMD-check będzie krzyczał, że `Sepal.Length` nie ma globalnej definicji. W takim wypadku używamy wyrażenia `.data` z `rlang` i piszemy `dplyr::mutate(iris, milimeters = .data$Sepal.Length * 10)`.\n\n3. Jeśli w funkcjach wybierających kolumny, typu `select()`, piszemy nazwy kolumn, to podajemy je w cudzysłowie. Powód jest taki, jak wyżej, brak globalnej definicji, ale `.data` nie nadaje się do `tidyselect`. Dla przykładu zamiast `select(iris, Sepal.Width, Sepal.Length)` napiszemy `dplyr::select(iris, \"Sepal.Width\", \"Sepal.Length\")`.\n\n4. Na ogół lepiej używać natywnego potoku `|>` niż `%>%`. Jeśli chcemy używać potoku z `magrittr` używamy wcześniej `usethis::use_pipe()`.\n\nPoprawiona funkcja mogłaby więc wyglądać tak:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nopisowe <- function(df, group, ...) {\n  kolumny_do_policzenia <- enquos(...)\n\n  df |>\n    dplyr::group_by({{ group }}) |>\n    dplyr::summarise(\n      dplyr::across(\n        c(!!!kolumny_do_policzenia),\n        .fns = list(\n          N = \\(x) sum(!is.na(x)),\n          M = \\(x) mean(x, na.rm = TRUE),\n          SD = \\(x) stats::sd(x, na.rm = TRUE),\n          A = agricolae::skewness,\n          K = agricolae::kurtosis,\n          `NA` = \\(x) sum(is.na(x))\n        )\n      )\n    )\n}\n```\n:::\n\n\n## Dokumentowanie z `roxygen2`\n\nGdy mamy już naszą funkcję napisaną, przyszedł czas ją udokumentować. Robimy to specjalnym szkieletem dodawanym przez pakiet `roxygen2`. Możemy albo napisać go od podstaw, albo najechać kursorem na naszą funkcję i w RStudio wejść w menu Code → Insert Roxygen Skeleton (skrót klawiaturowy Ctrl+Alt+Shift+R). Taki szkielet szkieletu uzupełniamy ręcznie. Pokażmy to sobie na przykładzie.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Statystyki opisowe\n#'\n#' Funkcja licząca podstawowe statystyki opisowe: liczność, średnią, SD,\n#' skośność, kurtozę i liczbę braków danych.\n#'\n#' @param df ramka danych z kolumnami do policzenia.\n#' @param group kolumna do grupowania.\n#' @param ... nazwy kolumn, dla których mają być policzone statystyki.\n#'\n#' @return ramka danych z kolumnami `N`, `M`, `SD`, `A`, `K` i `NA`. Oryginalne nazwy\n#'     kolumn w formie przedrostka.\n#' @export\n#'\n#' @examples\n#' opisowe(iris, Species, Sepal.Width, Sepal.Length)\n```\n:::\n\n\nPierwsze, co zwraca uwagę, to fakt, że napisałem to po polsku. Owszem, można, ale jeśli chcemy udostępniać nasz kod na zewnątrz, lepiej dokumentować funkcje po angielsku.\n\nTen podstawowy opis zawiera kilka rzeczy:\n\n1. Na samej górze tytuł funkcji, który lapidarnie ale konkretnie opisuje przeznaczenie funkcji.\n\n2. Dalej opis działania funkcji. Również powinien być krótki i konkretny. Jeśli potrzebujemy więcej niż jednego akapitu, musimy jawnie napisać `@description`. W innym wypadku wystarczy zejść linijkę poniżej tytułu.\n\n3. Następnie mamy trzy tagi `@param`, gdzie każdy opisuje kolejny argument, jaki funkcja przyjmuje. Warto tutaj opisać postać, w jakiej argument musi zostać podany.\n\n4. Tag `@return` opisuje, co funkcja zwraca.\n\n5. Tag `@export` nie zawiera żadnych informacji. Umieszcza się go w tych funkcjach, do których użytkownik powinien mieć dostęp.\n\n6. Na samym końcu mamy `@examples`, czyli przykłady użycia funkcji. Przykłady są obowiązkowe i obowiązkowo muszą zadziałać. Jeśli jakiś przykład specjalnie zwraca błąd, należy go umieścić w klamrze `\\dontrun{}`, np. `\\dontrun{opisowe(iris)}`.\n\nDo tych podstawowych tagów możemy dodać m.in. także sekcje `@details` czy `@seealso`. Nasz kod generuje podstawową stronę w dokumentacji.\n\n::: {.light-mode}\n![Dokumentacja funkcji `opisowe()`.](ilustracje/pakiety-w-R/dokumentacja.png)\n:::\n\n::: {.dark-mode}\n![Dokumentacja funkcji `opisowe()`.](ilustracje/pakiety-w-R/dokumentacja_dark.png)\n:::\n\nŻeby rzeczywiście przerobić szkielety `roxygen2` na pliki dokumentacji, należy uruchomić komendę `devtools::document()`. Pod koniec opiszę wszystkie podstawowe komendy, które warto uruchamiać przed każdym wypchnięciem do GitHuba.\n\nNa widać teź, że mogę używać formatowania markdown. Jest to jednak możliwe tylko wtedy, gdy wcześniej użyłem `usethis::use_roxygen_md()`, o czym wspominałem w podrozdziale [-@sec-structure].\n\n## Dokumentacja całego pakietu\n\nMożemy dodać ogólną stronę w dokumentacji dotyczącą naszego pakietu jako całości. Wykonuje się to w specjalnym pliku .R, który można dodać funkcją `usethis::use_package_doc()`. Jeśli jednak użyłeś(-aś) wcześniej funkcji `usethis::use_tidy_dependencies()`, to wymusiła ona na Tobie wytworzenie takiego pliku. Jeśli to zrobiłeś(-aś), to znajdziesz w folderze `R` plik typu `packagename-package.R`, gdzie możesz napisać dokumentację standardowo, jak w każdym innym pliku .R.\n\n## Dokumentacja plików z danymi\n\nJeśli załączamy w naszym pakiecie dane (o czym więcej w podrodziale [-@sec-datafiles]), to je również powinniśmy udokumentować. Tworzymy w tym celu specjalny plik `data.R` w folderze `R`, w którym opisujemy wszystkie nasze pliki z danymi. Pod szkieletem `roxygen2` umieszczamy nazwę naszego pliku w cudzysłowie. Poniżej skrócony przykład.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Creativity assessment through semantic distance dataset\n#'\n#' A dataset from Forthmann, Karwowski & Beaty ([2023](https://doi.org/10.1037/aca0000571)) paper.\n#' It contains a set of responses in Alternative Uses Task for different items with their\n#' semantic distance assessment.\n#'\n#' @return a [tibble][tibble::tibble-package]\n#' @format ## `mtscr_creativity`\n#' A `tibble` with 4585 rows and 10 columns:\n#' \\describe{\n#'   \\item{id}{patricipants' unique identification number}\n#'   \\item{response}{response in AUT}\n#'   \\item{item}{item for which alternative uses were searched for}\n#' }\n#'\n#' @source <https://osf.io/7rgsp/>\n\"mtscr_creativity\"\n```\n:::\n\n\nSpecyficzne tagi to `@format`, w którym opisujemy każdą kolumnę i `@source`, w którym podajemy źródło naszych danych.\n\n# Załączanie danych {#sec-datafiles}\n\n# R-CMD-check\n\n# Sprawdzanie wejścia i informacje o błędach\n\n# Testy z `testthat`\n\n# *Code coverage* z `codecov`\n\n# Bonus: załączanie apki w Shiny\n\n# Podsumowanie",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}