---
title: "Jak wspólnie pisać analizę statystyczną?"
subtitle: "Git, GitHub i integracja z RStudio"
description: "Przestawienie się z programu typu SPSS na R daje nam wiele korzyści, w tym umożliwia łatwe wspólne pisanie analiz statystycznych. W końcu kod to tekst, skoro możemy w Google Docs wspólnie tworzyć dokumenty, to czemu nie mielibyśmy wspólnie pisać analizy statystycznej? Do współpracy przy kodzie nie wykorzystujemy jednak Google Docs, ale specjalny protokół znany jako Git."
image: ./headers/git.webp
categories:
    - Narzędzia
    - R
draft: true
---

Kiedyś (a niekiedy do dziś) wspólne pisanie dokumentów czy prezentacji polegało na wysyłaniu sobie serii załączników mailem. Gdy zespół liczył więcej niż 2 osoby, szybko kolejne wersje danego pliku stawały się trudne do śledzenia. Podobnie gdy pisaliśmy coś na więcej niż jednym komputerze. Te problemy w większości odeszły w niepamięć, gdy nastała era chmury i współpracy online. Znacznie wcześniej powstawały jednak inne rozwiązania tego problemu -- systemy kontroli wersji, spośród których monopol na rynku zdobyło otwartoźródłowe dzieło Linusa Torvaldsa (twórcy Linuksa) o nazwie Git.

# Systemy kontroli wersji

Systemy kontroli wersji najogólniej polegają na tym, że śledzą zmiany w plikach. Jeśli dopisaliśmy akapit do naszego pliku i zatwierdziliśmy tę zmianę, system kontroli wersji będzie wiedział kto i kiedy wprowadził daną zmianę. Jeśli kilku użytkowników wprowadziło zmiany, które ze sobą nie konfliktują, system kontroli wersji potrafi takie zmienione pliki połączyć w jeden. Możemy dzięki temu prześledzić historię danego pliku, a także upewnić się, że wszyscy pracują na najnowszej wersji.

Jednocześnie jest to zrobione w sposób dostosowany do pisania kodu. Gdy piszemy kod, zazwyczaj wprowadzamy jakieś zmiany, testujemy, zazwyczaj nie działa, poprawiamy i tak aż nie zadziała. Jeśli mielibyśmy jeden wspólny plik, jak w Google Docs, nasze testy skutecznie uniemożliwiłyby wszystkim innym korzystanie z naszego kodu. Dlatego właśnie Git wymaga od nas, żeby zmiany w kodzie zatwierdzać i dopiero wtedy możemy udostępnić je innym. Dzięki temu tworzy się balans między współpracą i niewchodzeniem sobie w paradę.

Powstaje nam więc stabilny workflow -- wprowadź poprawki w kodzie, przetestuj, zatwierdź, opublikuj. Jak to zrobić w praktyce?

# Przygotowanie

Przygotowanie do korzystania z Gita może wyglądać bardzo różnie. Tutaj zaproponuję serię programów, które, mam nadzieję, uczynią ten proces jak najbardziej bezbolesnym. Postaram się też do minimum ograniczyć potrzebę korzystania z konsoli.

## Git

Żeby móc korzystać z dobrodziejstw Gita, musimy go sobie najpierw zainstalować. Chyba że korzystamy z dystrybucji Linuksa, wtedy mamy Git od początku. Nic dziwnego, Git powstał po to, żeby cała społeczność mogła dołożyć cegiełkę do [jądra Linuksa](https://github.com/torvalds/linux). Jeśli korzystamy z Windowsa, możemy pobrać podstawowy pakiet [stąd](https://git-scm.com/).

Gdy Git zostanie zainstalowany, musimy dokonać podstawowej konfiguracji, do której **my wykorzystamy GitHub CLI** i zrobimy ją w kolejnym podrozdziale. Jeśli jednak nie chcemy korzystać z jakiegoś powodu z GitHub CLI, możemy się skonfigurować lokalnie. W tym celu otwieramy konsolę (PowerShell lub wiersz polecenia w Windowsie) i wpisujemy tam dwie komendy, jedną po drugiej. **Nie polecam tego robić, jeśli nie ma się powodu.** Pierwsza komenda przypisze do lokalnego Gita nasz email:

```{bash}
git config --global user.email "adres@email.com"
```

Oczywiście za adres\@email.com podstawiamy nasz własny adres. Powinien to być ten sam adres, **którego potem użyjemy do założenia konta na GitHubie**. Komendę zatwierdzamy enterem. Jeśli konsola nie znajduje polecenia `git`, trzeba sprawdzić, czy na pewno zainstalowaliśmy git oraz zrestartować komputer. Druga komenda ustawia nazwę użytkownika.

```{bash}
git config --global user.name "nazwa-uzytkownika"
```

Ponownie, powinna być to taka sama nazwa użytkownika, jaką będziemy mieć na GitHubie. W razie czego zawsze można ją zmienić tą samą komendą.

## GitHub i GitHub CLI

Git to protokół działający lokalnie. Innymi słowy nasz własny Git jest w naszym własnym folderze i inni ludzie nie mają do niego dostępu. To jest ok, jeśli chcemy robić kontrolę wersji do własnego użytku. Jeśli jednak chcemy współpracować z innymi albo mieć dostęp do naszego kodu na różnych komputerach, potrzebujemy jakiegoś rodzaju usługi internetowej, z którą każdy może się połączyć. Podstawowym *de facto* hostingiem tego typu jest [GitHub](https://github.com/). To jest więc dobry moment, żeby wejść na GitHuba i założyć tam konto.

To jest moment na szybkie wtrącenie, które może nam ułatwić życie w późniejszej konfiguracji RStudio. Warto jest w tym momencie wejść w ustawienia RStudio, tam w zakładkę Git/SVN i sprawdzić, czy RStudio podaje jakąś ścieżkę dla SSH key. Jeśli nie, klikamy „Create SSH key" i zatwierdzamy. Nie musimy wpisywać hasła.

GitHub dysponuje też wersją konsolową, GitHub CLI, która pozwoli nam bezboleśnie połączyć naszego lokalnego Gita z kontem na GitHubie. GitHub CLI pobieramy [stąd](https://cli.github.com/). Po zainstalowaniu (i ewentualnym restarcie komputera) możemy skonfigurować Git. W tym celu otwieramy konsolę (PowerShell lub wiersz polecenia w Windowsie) i wpisujemy tam:

```{bash}
gh auth login
```

Po zatwierdzeniu komendy enterem powinien uruchomić się kreator, który bezboleśnie przeprowadzi nas przez proces logowania. Najpierw wybieramy, że chcemy się się logować do zwykłego GitHub.com. Następnie musimy wybrać protokół. Na ogół łatwiejszy do ogarnięcia jest HTTPS, jednak na potrzeby RStudio lepiej jest wybrać SSH. Jeśli wytworzyliśmy wcześniej klucz SSH w RStudio, GitHub CLI zapyta nas teraz, czy wysłać ów klucz na serwer. Tak, to jest dokładnie to, co chcemy zrobić. Następnie klucz tytułujemy jak chcemy (lub klikamy enter, jeśli odpowiada nam tytuł GitHub CLI) i wybieramy logowanie za pomocą przeglądarki. W tym momencie wyświetli nam się kod, który powinniśmy skopiować. Jeśli chcesz użyć skrótu klawiaturowego, **nie używaj Ctrl+C**, bo wyłączysz GitHub CLI. Użyj Ctrl+Shift+C. Możesz też użyć myszki. Po kliknięciu enter otworzy nam się okno przeglądarki, gdzie wklejamy wcześniej skopiowany kod i zatwierdzamy.

W ten sposób dokonaliśmy konfiguracji GitHub CLI. Pozostaje nam jeszcze połączyć GitHub CLI z naszym lokalnym Gitem za pomocą prostej komendy:

```{bash}
gh auth git-setup
```

## GitHub Desktop i GitKraken

Domyślnie Git jest narzędziem konsolowym. Dla większości świeżych użytkowników jest to nie do przejścia. Sam widok okna terminala może wywoływać obfite pocenie, przyspieszenie akcji serca i wyrzut kortyzolu do krwi. Na szczęście istnieją przynajmniej dwa narzędzia, które mogą nam oszczędzić męki uczenia się poleceń konsolowych.

Pierwsze z nich to [GitHub Desktop](https://desktop.github.com/), który jest intuicyjnym programem pozwalającym nam na szybkie zarządzanie Gitem i synchronizację z GitHubem. Jest to narzędzie darmowe i [otwartoźródłowe](https://github.com/desktop/desktop). Pozwala nam nie tylko zatwierdzać, wysyłać i odbierać zmiany, ale także możemy za jego pomocą zarządzać *pull requests* (więcej o tym później).

![](ilustracje/git/GitHub-Desktop.png)

Druga możliwość to [GitKraken](https://www.gitkraken.com/). Potężne narzędzie do zarządzania Gitem z wieloma zaawansowanymi możliwościami jak wyświetlanie wykresów commitów i modyfikacje na miejscu. Niestety GitKraken to program płatny, ale dostępny za darmo dla studentów i pracowników naukowych w ramach [GitHub Education](https://education.github.com/discount). Nie jest to jedyna korzyść płynąca z tego programu (inne to np. GitHub Copilot), także polecam się zainteresować.

![](ilustracje/git/GitKraken.png)

Możemy wybrać dowolne z tych narzędzi, bo funkcjonalność mają podobną. Jeśli jednak mamy statuts studenta albo pracownika naukowego, polecam GitKraken o tyle, że pozwala dość łatwo rozwiązać specyficzne problemy. Tak czy inaczej, będą to dla nas dodatkowe narzędzia, jeśli planujemy korzystać z Gita głównie do wspólnego pisania kodu R w RStudio, ponieważ RStudio samo w sobie ma wbudowaną integrację z Gitem.

# Podstawowe pojęcia

Gdy tworzymy projekt w RStudio, możemy zaznaczyć, żeby jednocześnie stworzyć **repozytorium** Git. Repozytorium to w pewnym sensie folder, w którym zgromadzony jest nasz kod. Co odróżnia zwykły folder z kodem od repozytorium Git? Głównie ukryty folder `.git`, który śledzi zmiany, jakie wprowadzamy w plikach. Jeśli nie zainicjowaliśmy od razu, żaden problem, możemy to zrobić później, wybierając opcję stworzenia repozytorium w naszym programie do zarządzania Gitem. Jeśli jest to repozytorium z kodem R, warto po utworzeniu repozytorium jednorazowo użyć w R komendy `usethis::git_vaccinate()`. Sprawi ona, że Git będzie ignorował pliki, których nie powinniśmy zapisywać w repozytorium.

Jeśli w RStudio otworzymy projekt z repozytorium Git, zobaczymy w prawym górnym okienku zakładkę Git. W niej pliki, które zmieniliśmy lub dodaliśmy od ostatniego razu. Możemy te pliki zaznaczyć, żeby zatwierdzić wprowadzone zmiany. Taki zatwierdzony zestaw zmian nazywa się ***commit***. Taki commit obowiązkowo musi zostać opatrzony skrótową wiadomością z opisem, co zmieniliśmy. Pierwsza linijka to skrótowa informacja w kilku słowach, ale możemy też dodać więcej informacji po zostawieniu wolnej linijki. To samo możemy też zrobić z poziomu wybranego przez nas menedżera Gita.

Jak często robić commity? To już zależy od nas. Możemy z każdej działającej poprawki robić osobny commit, a możemy robić jeden wielki commit co jakiś czas. Najlepiej jednak robić je częściej niż rzadziej. Częste commity mają tę zaletę, że w razie czego możemy wycofać jakieś commity. W razie takiej potrzeby, częstsze commity to mniej korzystnego kodu zostaje utracone. Ostatecznie powinna nam przyświecać zasada, że jedna rzecz to jeden commit. Od nas jednak zależy, co uznamy za rzecz.

Domyślnie commity zapisują się tylko na naszym dysku twardym. Jeśli chcemy wysłać je na GitHuba możemy użyć guzika ***push*** w RStudio albo w menedżerze Gita. Żeby ta opcja była dostępna, musimy najpierw opublikować nasze repozytorium, co łatwo zrobić z poziomu GitHub Desktop czy GitKraken.

Przeciwieństwem *push* jest ***pull***. *Pull* służy do pobrania zmian, które wcześniej my albo ktoś inny wysłaliśmy na serwer. Warto jest to robić często, przed rozpoczęciem pracy. *Pull* wymaga, żebyśmy już mieli repozytorium na dysku. Jeśli chcemy pobrać całe repozytorium, musimy je ***sklonować***. Klonowanie najłatwiej wykonać z poziomu menedżera.

Podstawowy workflow jest więc następujący:

1. *Pull*.

2. Piszemy kod i testujemy.

3. *Commit*.

4. *Push*.

# Pliki specjalne

Repozytoria na GitHubie często mają kilka plików specjalnych, z których najważniejsze to `README.md` i `.gitignore`. Omówmy sobie oba.

## `.gitignore`

Plik `.gitignore` to informacja dla Git, żeby pewne konkretne pliki albo rodzaje plików (np. wszystkie pliki .csv) ignorował. Innymi słowy, żeby nie krzyczał nam, że wykrywa taki plik, trzeba go śledzić. Podstawowe rodzaje plików dla R dodaje wspomniana już komenda `usethis::git_vaccinate()` albo RStudio, jeśli tworzyliśmy repozytorium za jego pomocą. Menedżery biblografii potrafią nam również przygotować taki roboczy plik podczas tworzenia repozytorium.

Możemy otworzyć ten plik w dowolnym edytorze tekstu. Możemy też w RStudio użyć komendy `usethis::edit_git_ignore()`, która nam ten plik otworzy. Możemy dopisać tam nazwy lub ścieżki plików, które Git ma ignorować. Możemy też dopisać `*.csv`, żeby zignorować wszystkie pliki .csv. Gwiazdka `*` oznacza dowolne znaki. Możemy również dodawać pojedyncze pliki w R za pomocą komendy `usethis::use_git_ignore()`.

## `README.md`

Plik README to jest to, co wyświietla się, jak na GitHubie wejdziemy na stronę repozytorium. Możemy tam zapisywać podstawowe informacje dla odbiorców naszego repozytorium. Sam plik korzysta z formatowania GitHub Markdown, którego opis znajdziemy [tutaj](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax). Jeśli piszemy analizę w R, warto użyć komendy `usethis::use_readme_md()`, żeby taki wzorcowy przykładowy plik wytworzyć. Dla kodu w R warto rozważyć, czy nie przerzucić się na plik README.Rmd wytwarzany przez `usethis::use_readme_rmd()`. Pozwala on do pliku README dorzucać np. bloki kodu R. Dla publicznego kodu to szczególnie cenne, bo możemy pokazać przykładowe działanie naszych funkcji. Wtedy edytujemy plik README.Rmd, zaś przed samym wypchnięciem używamy funkcji `devtools::build_readme()`, żeby przerobić go na README.md. Wtedy korzystamy ze składni R Markdown.